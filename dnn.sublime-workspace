{
	"auto_complete":
	{
		"selected_items":
		[
			[
<<<<<<< HEAD
				"input_s",
				"input_stream"
			],
			[
				"modul",
				"modulateReward"
			],
			[
				"SpikeN",
				"SpikeNeuronBase"
			],
			[
				"rein",
				"reinforce"
			],
			[
				"reinfo",
				"reinforce"
			],
			[
				"chec",
				"checkVal"
			],
			[
				"local",
				"localId"
			],
			[
				"reinfor",
				"reinforcements"
			],
			[
				"confg",
				"configureRewardControl"
			],
			[
				"seria",
				"serial_process"
			],
			[
				"output",
				"output_stream"
			],
			[
				"gath",
				"gathered_reward"
			],
			[
				"Rewa",
				"RewardControl"
			],
			[
				"tau_me",
				"tau_mean_trace"
			],
			[
				"Seri",
				"Serializable"
			],
			[
				"Spik",
				"SpikeSequenceNeuron"
			],
			[
				"getTime",
				"getInputTimeSeriesInfo"
			],
			[
				"labe",
				"labels_timeline"
			],
			[
				"TIme",
				"TimeSeries"
			],
			[
				"nam",
				"name2fname"
			],
			[
				"L_",
				"L_INFO"
			],
			[
				"TimeSeri",
				"TimeSeriesInfo"
			],
			[
				"TimeSer",
				"TimeSeriesInfo"
			],
			[
				"label",
				"labels_timeline"
			],
			[
				"defa",
				"default_const_json"
			],
			[
				"string",
				"stringify"
			],
			[
				"neuron",
				"neurons_to_listen"
			],
			[
				"sim_c",
				"sim_conf_doc"
			],
			[
				"do",
				"document"
			],
			[
				"const",
				"const_json"
			],
			[
				"clean",
				"cleanHeap"
			],
			[
				"Time",
				"TimeSeries"
			],
			[
				"lay",
				"layers"
			],
			[
				"Mem",
				"MemberEnd"
			],
			[
				"spec",
				"spec_json"
			],
			[
				"la",
				"layer_conf"
			],
			[
				"lear",
				"learning_rule"
			],
			[
				"den",
				"dendrite_delay"
			],
			[
				"Remove",
				"RemoveMember"
			],
			[
				"laye",
				"layer_conf_json"
			],
			[
				"fin",
				"FindMember"
			],
			[
				"layer_",
				"layer_spec"
			],
			[
				"layer",
				"layer_spec"
			],
			[
				"strin",
				"stringify"
			],
			[
				"Cha",
				"CharacterVector"
			],
			[
				"sec",
				"section"
			],
			[
				"simu",
				"simulation"
			],
			[
				"obj",
				"obj_name"
			],
			[
				"Fil",
				"FilterMatch"
			],
			[
				"Ma",
				"MatchingPursuitConfig"
			],
			[
				"Sp",
				"SpikeNeuronBase"
			],
			[
				"Subs",
				"Subsequence"
			],
			[
				"Sta",
				"Statistics"
			],
			[
				"mess",
				"messages"
			],
			[
				"null",
				"nullptr"
			],
			[
				"regi",
				"registerObject"
=======
				"kern",
				"kern_res"
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
			],
			[
				"Ker",
				"KernelWorker"
			],
			[
				"res",
				"results"
			],
			[
				"row",
				"rowLabelsIds"
			],
			[
				"uni",
				"uniqueLabels"
			],
			[
				"data",
				"data_serial"
			],
			[
				"Kern",
				"KernelWorker"
			],
			[
				"create",
				"createObjectFactory"
			],
			[
				"arr",
				"arr_to_sort"
			],
			[
				"del",
				"delimiter"
			],
			[
				"getK",
				"getKernelPreprocessorsMap"
			],
			[
				"proc_map",
				"proc_map_type"
			],
			[
				"kerne",
				"kernel_map"
			],
			[
				"kernel_",
				"kernel_preproc_spec"
			],
			[
				"kernel",
				"kernel_map"
			],
			[
				"Rbf",
				"RbfDotKernel"
			],
			[
				"find_",
				"find_first_of"
			],
			[
				"Doub",
				"DoubleMatrix"
			],
			[
				"val",
				"values"
			],
			[
				"param",
				"param_name"
			],
			[
				"Epsp",
				"EpspKernel"
			],
			[
				"double",
				"doubleParser"
			],
			[
				"kernel_proc",
				"kernel_proc_map"
			],
			[
				"Kernel",
				"KernelFun"
			],
			[
				"IKe",
				"IKernelProcessor"
			],
			[
				"Kerne",
				"KernelBase"
			],
			[
				"Emp",
				"EmptyOptions"
			],
			[
				"conv",
				"convertMatchesToSpikes"
			],
			[
				"Spikes",
				"SpikesList"
			],
			[
				"match",
				"matches"
			],
			[
				"mem",
				"membrane"
			],
			[
				"Seri",
				"SerializableBase"
			],
			[
				"padd",
				"paddingNfft"
			],
			[
				"out",
				"out_size"
			],
			[
				"anot",
				"another_ts_di"
			],
			[
				"next",
				"next_pow2"
			],
			[
				"nff",
				"nfft_next"
			],
			[
				"spik",
				"spikework_args"
			],
			[
				"kiss",
				"kiss_fft_cpx"
			],
			[
				"kiss_fft_",
				"kiss_fft_scalar"
			],
			[
				"new_",
				"new_right_hist"
			],
			[
				"unord",
				"unordered_map"
			],
			[
				"pruned",
				"pruned_ig"
			],
			[
				"right_",
				"right_classes_hist"
			],
			[
				"max_",
				"max_further_ig"
			],
			[
				"class",
				"class_hist"
			],
			[
				"prun",
				"pruned_ig"
			],
			[
				"algo",
				"algo_stat"
			],
			[
				"best_",
				"best_split"
			],
			[
				"num",
				"numberOfPruned"
			],
			[
				"push",
				"push_back"
			],
			[
				"orde",
				"orderline"
			],
			[
				"unor",
				"unordered_map"
			],
			[
				"right_ma",
				"right_major_classes"
			],
			[
				"left_ma",
				"left_major_classes"
			],
			[
				"poor",
				"poorCache"
			],
			[
				"entrop",
				"entropy_right"
			],
			[
				"best_s",
				"best_subsequence"
			],
			[
				"Ser",
				"SerializableBase"
			],
			[
				"Seril",
				"SerializableBase"
			],
			[
				"better",
				"betterSplitStats"
			],
			[
				"dist",
				"distance"
			],
			[
				"split_po",
				"split_position"
			],
			[
				"left_",
				"left_classes_hist"
			],
			[
				"split_",
				"split_stat"
			],
			[
				"prj",
				"projs"
			],
			[
				"Sub",
				"subsequence"
			],
			[
				"getVa",
				"getValueAt"
			],
			[
				"mean",
				"mean_prod"
			],
			[
				"cumS",
				"cumSumsSquared"
<<<<<<< HEAD
=======
			],
			[
				"_id",
				"_id_from"
			],
			[
				"class_",
				"class_ids"
			],
			[
				"config",
				"config_file"
			],
			[
				"meaProd",
				"meanProdMatrix"
			],
			[
				"squ",
				"squaredCumulativeSums"
			],
			[
				"cum",
				"cumulativeSum"
			],
			[
				"_len",
				"_length"
			],
			[
				"cumu",
				"cumulativeSums"
			],
			[
				"curren",
				"currentTs"
			],
			[
				"sub",
				"subsequence"
			],
			[
				"refere",
				"referent"
			],
			[
				"serial",
				"serial_process"
			],
			[
				"curr",
				"currentTs"
			],
			[
				"Time",
				"TimeSeries"
			],
			[
				"TimeS",
				"TimeSeries"
			],
			[
				"time_",
				"time_series_stat"
			],
			[
				"chop",
				"chopped"
			],
			[
				"Tim",
				"TimeSeries"
			],
			[
				"read",
				"readObject"
			],
			[
				"input",
				"input_file"
			],
			[
				"struct",
				"structures"
			],
			[
				"sha",
				"shapeletsEndSize"
			],
			[
				"shap",
				"shapeletsStartSize"
			],
			[
				"Shap",
				"ShapeletsConfig"
			],
			[
				"print",
				"printNow"
			],
			[
				"spike",
				"spike_time"
			],
			[
				"mode",
				"mode_str"
			],
			[
				"dim",
				"dimenstions"
			],
			[
				"col",
				"col_labels_ids"
			],
			[
				"uniq",
				"unique_labels"
			],
			[
				"matr",
				"matrix_info"
			],
			[
				"labe",
				"labels_timeline"
			],
			[
				"row_",
				"row_labels_ids"
			],
			[
				"lab_",
				"lab_ptr"
			],
			[
				"elem",
				"elem_id"
			],
			[
				"ts",
				"ts_chopped"
			],
			[
				"gram",
				"gram_matrix"
			],
			[
				"strings",
				"stringstream"
			],
			[
				"repl",
				"repl_num"
			],
			[
				"spec",
				"specification"
			],
			[
				"TimeSer",
				"TimeSeries"
			],
			[
				"ker",
				"kernel_length"
			],
			[
				"Spike",
				"SpikesList"
			],
			[
				"filt",
				"filter"
			],
			[
				"Conv",
				"ConvProcessor"
			],
			[
				"filter",
				"filter_fname"
			],
			[
				"TimeSeriesC",
				"TimeSeriesComplexData"
			],
			[
				"dim_i",
				"dim_info"
			],
			[
				"tem",
				"template"
			],
			[
				"subv",
				"subv_imag"
			],
			[
				"fiel",
				"field_descr"
			],
			[
				"kiss_fft",
				"kiss_fftndr    (kiss_fftndr.c)"
			],
			[
				"Spik",
				"Spikework::Field   (spikework.h)"
			],
			[
				"Proce",
				"Processor  (spikework.h)"
			],
			[
				"proce",
				"processArgs    (spikework.h)"
			],
			[
				"Spikework",
				"SpikeworkField"
			],
			[
				"turnO",
				"turnOnStatistics"
			],
			[
				"ampl",
				"apply_amplitude"
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
			]
		]
	},
	"buffers":
	[
<<<<<<< HEAD
=======
		{
			"contents": "Searching 364 files for \"\\+\\++\" (regex)\n\n/home/alexeyche/prog/dnn/dnn_project/.tags:\n 1262  Put	dnn/contrib/rapidjson/memorybuffer.h	/^    void Put(Ch c) { *stack_.template Push<Ch>() = c; }$/;\"	f	struct:GenericMemoryBuffer\n 1263  Put	dnn/contrib/rapidjson/memorystream.h	/^    void Put(Ch) { RAPIDJSON_ASSERT(false); }$/;\"	f	struct:MemoryStream\n 1264: Put	dnn/contrib/rapidjson/rapidjson.h	/^    void Put(Ch c) { RAPIDJSON_ASSERT(dst_ != 0); *dst_++ = c; }$/;\"	f	struct:GenericInsituStringStream\n 1265  Put	dnn/contrib/rapidjson/rapidjson.h	/^    void Put(Ch) { RAPIDJSON_ASSERT(false); }$/;\"	f	struct:GenericStringStream\n 1266  Put	dnn/contrib/rapidjson/reader.h	/^        RAPIDJSON_FORCEINLINE void Put(Ch c) {$/;\"	f	class:GenericReader::StackStream\n ....\n 1791  Take	dnn/contrib/rapidjson/filestream.h	/^    char Take() { char c = current_; Read(); return c; }$/;\"	f	class:FileStream\n 1792  Take	dnn/contrib/rapidjson/filewritestream.h	/^    char Take() { RAPIDJSON_ASSERT(false); return 0; }$/;\"	f	class:FileWriteStream\n 1793: Take	dnn/contrib/rapidjson/memorystream.h	/^    Ch Take() { return (src_ == end_) ? '\\\\0' : *src_++; }$/;\"	f	struct:MemoryStream\n 1794: Take	dnn/contrib/rapidjson/rapidjson.h	/^    Ch Take() { return *src_++; }$/;\"	f	struct:GenericInsituStringStream\n 1795: Take	dnn/contrib/rapidjson/rapidjson.h	/^    Ch Take() { return *src_++; }$/;\"	f	struct:GenericStringStream\n 1796  Take	dnn/contrib/rapidjson/reader.h	/^        RAPIDJSON_FORCEINLINE Ch Take() { return is.Take(); }$/;\"	f	class:GenericReader::NumberStream\n 1797  TakeBOM	dnn/contrib/rapidjson/encodings.h	/^    static CharType TakeBOM(InputByteStream& is) {$/;\"	f	struct:ASCII\n ....\n 3593  operator +	dnn/contrib/rapidjson/document.h	/^    Iterator operator+(DifferenceType n) const { return Iterator(ptr_+n); }$/;\"	f	class:GenericMemberIterator\n 3594  operator +	dnn/util/random/pcg_uint128.hpp	/^uint_x4<UInt,UIntX2> operator+(const uint_x4<UInt,UIntX2>& a,$/;\"	f	namespace:pcg_extras\n 3595: operator ++	dnn/base/base.h	/^    void operator ++() {$/;\"	f	struct:dnn::Time\n 3596: operator ++	dnn/contrib/rapidjson/document.h	/^    Iterator  operator++(int){ Iterator old(*this); ++ptr_; return old; }$/;\"	f	class:GenericMemberIterator\n 3597: operator ++	dnn/contrib/rapidjson/document.h	/^    Iterator& operator++(){ ++ptr_; return *this; }$/;\"	f	class:GenericMemberIterator\n 3598  operator +=	dnn/contrib/rapidjson/document.h	/^    Iterator& operator+=(DifferenceType n) { ptr_+=n; return *this; }$/;\"	f	class:GenericMemberIterator\n 3599  operator +=	dnn/contrib/rapidjson/internal/biginteger.h	/^    BigInteger& operator+=(uint64_t u) {$/;\"	f	class:internal::BigInteger\n\n/home/alexeyche/prog/dnn/dnn_project/.tags_sorted_by_file:\n   57  getValueAtIndexDelegate	dnn/base/base.h	/^typedef FastDelegate1<const size_t&, const double&> getValueAtIndexDelegate;$/;\"	t	namespace:dnn\n   58  n_id	dnn/base/base.h	/^    size_t n_id;$/;\"	m	struct:dnn::SynSpike\n   59: operator ++	dnn/base/base.h	/^    void operator ++() {$/;\"	f	struct:dnn::Time\n   60  operator <	dnn/base/base.h	/^    bool operator<(const SynSpike& rhs) const {$/;\"	f	struct:dnn::SynSpike\n   61  operator <	dnn/base/base.h	/^    bool operator<(const double &dur) const {$/;\"	f	struct:dnn::Time\n   ..\n  604  operator *	dnn/contrib/rapidjson/document.h	/^    Reference operator*() const { return *ptr_; }$/;\"	f	class:GenericMemberIterator\n  605  operator +	dnn/contrib/rapidjson/document.h	/^    Iterator operator+(DifferenceType n) const { return Iterator(ptr_+n); }$/;\"	f	class:GenericMemberIterator\n  606: operator ++	dnn/contrib/rapidjson/document.h	/^    Iterator  operator++(int){ Iterator old(*this); ++ptr_; return old; }$/;\"	f	class:GenericMemberIterator\n  607: operator ++	dnn/contrib/rapidjson/document.h	/^    Iterator& operator++(){ ++ptr_; return *this; }$/;\"	f	class:GenericMemberIterator\n  608  operator +=	dnn/contrib/rapidjson/document.h	/^    Iterator& operator+=(DifferenceType n) { ptr_+=n; return *this; }$/;\"	f	class:GenericMemberIterator\n  609  operator -	dnn/contrib/rapidjson/document.h	/^    DifferenceType operator-(ConstIterator that) const { return ptr_-that.ptr_; }$/;\"	f	class:GenericMemberIterator\n  ...\n 1120  PutEnd	dnn/contrib/rapidjson/memorystream.h	/^    size_t PutEnd(Ch*) { RAPIDJSON_ASSERT(false); return 0; }$/;\"	f	struct:MemoryStream\n 1121  RAPIDJSON_MEMORYSTREAM_H_	dnn/contrib/rapidjson/memorystream.h	22;\"	d\n 1122: Take	dnn/contrib/rapidjson/memorystream.h	/^    Ch Take() { return (src_ == end_) ? '\\\\0' : *src_++; }$/;\"	f	struct:MemoryStream\n 1123  Tell	dnn/contrib/rapidjson/memorystream.h	/^    size_t Tell() const { return static_cast<size_t>(src_ - begin_); }$/;\"	f	struct:MemoryStream\n 1124  begin_	dnn/contrib/rapidjson/memorystream.h	/^    const Ch* begin_;   \\/\\/!< Original head of the string.$/;\"	m	struct:MemoryStream\n ....\n 1473  Pop	dnn/contrib/rapidjson/rapidjson.h	/^    void Pop(size_t count) { dst_ -= count; }$/;\"	f	struct:GenericInsituStringStream\n 1474  Push	dnn/contrib/rapidjson/rapidjson.h	/^    Ch* Push(size_t count) { Ch* begin = dst_; dst_ += count; return begin; }$/;\"	f	struct:GenericInsituStringStream\n 1475: Put	dnn/contrib/rapidjson/rapidjson.h	/^    void Put(Ch c) { RAPIDJSON_ASSERT(dst_ != 0); *dst_++ = c; }$/;\"	f	struct:GenericInsituStringStream\n 1476  Put	dnn/contrib/rapidjson/rapidjson.h	/^    void Put(Ch) { RAPIDJSON_ASSERT(false); }$/;\"	f	struct:GenericStringStream\n 1477  PutBegin	dnn/contrib/rapidjson/rapidjson.h	/^    Ch* PutBegin() { RAPIDJSON_ASSERT(false); return 0; }$/;\"	f	struct:GenericStringStream\n ....\n 1535  StreamTraits	dnn/contrib/rapidjson/rapidjson.h	/^struct StreamTraits<GenericStringStream<Encoding> > {$/;\"	s\n 1536  StringStream	dnn/contrib/rapidjson/rapidjson.h	/^typedef GenericStringStream<UTF8<> > StringStream;$/;\"	t\n 1537: Take	dnn/contrib/rapidjson/rapidjson.h	/^    Ch Take() { return *src_++; }$/;\"	f	struct:GenericInsituStringStream\n 1538: Take	dnn/contrib/rapidjson/rapidjson.h	/^    Ch Take() { return *src_++; }$/;\"	f	struct:GenericStringStream\n 1539  Tell	dnn/contrib/rapidjson/rapidjson.h	/^    size_t Tell() const { return static_cast<size_t>(src_ - head_); }$/;\"	f	struct:GenericStringStream\n 1540  Tell	dnn/contrib/rapidjson/rapidjson.h	/^    size_t Tell() { return static_cast<size_t>(src_ - head_); }$/;\"	f	struct:GenericInsituStringStream\n\n/home/alexeyche/prog/dnn/dnn_project/CMakeLists.txt:\n   27  if(DEBUG)\n   28    add_definitions(-DDEBUG)\n   29:   set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11 -g -O0\")\n   30    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -std=gnu99 -g -O0\")\n   31  elseif(PROFILE)\n   32    add_definitions(-DNDEBUG)\n   33:   set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11 -g -O3\")\n   34    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -std=gnu99 -g -O3\")\n   35  else()\n   36    add_definitions(-DNDEBUG)\n   37:   set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -std=c++11 -O3\")\n   38    set(CMAKE_C_FLAGS \"${CMAKE_C_FLAGS} -std=gnu99 -O3\")\n   39  endif(DEBUG)\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/base/base.h:\n   69      Time(double _dt) : t(0), dt(_dt) {\n   70      }\n   71:     void operator ++() {\n   72          t+=dt;\n   73      }\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/base/constants.cpp:\n   17  \n   18  void Constants::readString(string s, OptMods mods) {\n   19:     for(auto it=mods.begin(); it != mods.end(); ++it) {\n   20          replaceStr(s, it->first, it->second);\n   21      }\n   ..\n   43              const Value &layers_doc = Json::getArray(sim_conf_doc, \"layers\");\n   44  \n   45:             for (SizeType i = 0; i < layers_doc.Size(); i++) {\n   46                  const Value &v = layers_doc[i];\n   47                  sim_conf.layers.push_back(Json::stringify(v));\n   ..\n   51              const Value &conn_map_doc = Json::getVal(sim_conf_doc, \"conn_map\");\n   52  \n   53:             for (Value::ConstMemberIterator itr = conn_map_doc.MemberBegin(); itr != conn_map_doc.MemberEnd(); ++itr) {\n   54                  const string k = itr->name.GetString();\n   55                  vector<string> aff = splitBySubstr(k, \"->\");\n   ..\n   61                  const Value &conns = itr->value;\n   62  \n   63:                 for (SizeType i = 0; i < conns.Size(); i++) {\n   64                      const Value &v = conns[i];\n   65                      sim_conf.conn_map.insert( pair<pair<size_t, size_t>, string>(aff_p, Json::stringify(v) ));\n   ..\n   84          if(Json::checkVal(sim_conf_doc, \"files\")) {\n   85              const Value &files_doc = Json::getVal(sim_conf_doc, \"files\");\n   86:             for (Value::ConstMemberIterator itr = files_doc.MemberBegin(); itr != files_doc.MemberEnd(); ++itr) {\n   87                  const string k = itr->name.GetString();\n   88                  sim_conf.files[k] = Json::stringify(itr->value);\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/base/constants.h:\n   90  \n   91  	static void fill(const Value &v, map<string, string> &m) {\n   92: 		for (Value::ConstMemberIterator itr = v.MemberBegin(); itr != v.MemberEnd(); ++itr) {\n   93  			m[itr->name.GetString()] = Json::stringify(itr->value);\n   94  		}\n   ..\n  109  	static void print_section(const string &sect_name, const map<string, string> &m, ostream &o) {\n  110  		o << sect_name << \"\\n\";\n  111: 		for (auto it = m.begin(); it != m.end(); ++it) {\n  112  			o << \"\\t\" << it->first << \" :\";\n  113  			auto spl_doc = split(it->second, '\\n');\n  ...\n  115  				o << \" \" << spl_doc[0] << \"\\n\";\n  116  			}\n  117: 			for(size_t i=1; i<spl_doc.size(); ++i) {\n  118  				o << \"\\t\" <<  spl_doc[i] << \"\\n\";\n  119  			}\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/kiss_fft/kiss_fft.c:\n   37          C_SUB( *Fout2 ,  *Fout , t );\n   38          C_ADDTO( *Fout ,  t );\n   39:         ++Fout2;\n   40:         ++Fout;\n   41      }while (--m);\n   42  }\n   ..\n   86              Fout[m3].i = scratch[5].i + scratch[4].r;\n   87          }\n   88:         ++Fout;\n   89      }while(--k);\n   90  }\n   ..\n  130           Fout[m].i += scratch[0].r;\n  131  \n  132:          ++Fout;\n  133       }while(--k);\n  134  }\n  ...\n  157  \n  158      tw=st->twiddles;\n  159:     for ( u=0; u<m; ++u ) {\n  160          C_FIXDIV( *Fout0,5); C_FIXDIV( *Fout1,5); C_FIXDIV( *Fout2,5); C_FIXDIV( *Fout3,5); C_FIXDIV( *Fout4,5);\n  161          scratch[0] = *Fout0;\n  ...\n  191          C_SUB(*Fout3,scratch[11],scratch[12]);\n  192  \n  193:         ++Fout0;++Fout1;++Fout2;++Fout3;++Fout4;\n  194      }\n  195  }\n  ...\n  211      kiss_fft_cpx * scratch = (kiss_fft_cpx*)KISS_FFT_TMP_ALLOC(sizeof(kiss_fft_cpx)*p);\n  212  \n  213:     for ( u=0; u<m; ++u ) {\n  214          k=u;\n  215:         for ( q1=0 ; q1<p ; ++q1 ) {\n  216              scratch[q1] = Fout[ k  ];\n  217              C_FIXDIV(scratch[q1],p);\n  ...\n  220  \n  221          k=u;\n  222:         for ( q1=0 ; q1<p ; ++q1 ) {\n  223              int twidx=0;\n  224              Fout[ k ] = scratch[0];\n  225:             for (q=1;q<p;++q ) {\n  226                  twidx += fstride * k;\n  227                  if (twidx>=Norig) twidx-=Norig;\n  ...\n  246  {\n  247      kiss_fft_cpx * Fout_beg=Fout;\n  248:     const int p=*factors++; /* the radix  */\n  249:     const int m=*factors++; /* stage's fft length/p */\n  250      const kiss_fft_cpx * Fout_end = Fout + p*m;\n  251  \n  ...\n  259          // execute the p different work units in different threads\n  260  #       pragma omp parallel for\n  261:         for (k=0;k<p;++k) \n  262              kf_work( Fout +k*m, f+ fstride*in_stride*k,fstride*p,in_stride,factors,st);\n  263          // all threads have joined by this point\n  ...\n  278              *Fout = *f;\n  279              f += fstride*in_stride;\n  280:         }while(++Fout != Fout_end );\n  281      }else{\n  282          do{\n  ...\n  325          }\n  326          n /= p;\n  327:         *facbuf++ = p;\n  328:         *facbuf++ = n;\n  329      } while (n > 1);\n  330  }\n  ...\n  355          st->inverse = inverse_fft;\n  356  \n  357:         for (i=0;i<nfft;++i) {\n  358              const double pi=3.141592653589793238462643383279502884197169399375105820974944;\n  359              double phase = -2*pi*i / nfft;\n  ...\n  403          if (m<=1)\n  404              break; /* n is completely factorable by twos, threes, and fives */\n  405:         n++;\n  406      }\n  407      return n;\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/kiss_fft/kiss_fftnd.c:\n   34      char * ptr;\n   35  \n   36:     for (i=0;i<ndims;++i) {\n   37          size_t sublen=0;\n   38          kiss_fft_alloc (dims[i], inverse_fft, NULL, &sublen);\n   ..\n   67      ptr += sizeof(kiss_fft_cpx) * dimprod;\n   68  \n   69:     for (i=0;i<ndims;++i) {\n   70          size_t len;\n   71          st->dims[i] = dims[i];\n   ..\n  175          bufout = st->tmpbuf;\n  176  \n  177:     for ( k=0; k < st->ndims; ++k) {\n  178          int curdim = st->dims[k];\n  179          int stride = st->dimprod / curdim;\n  180  \n  181:         for ( i=0 ; i<stride ; ++i ) \n  182              kiss_fft_stride( st->states[k], bufin+i , bufout+i*curdim, stride );\n  183  \n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/kiss_fft/kiss_fftndr.c:\n   30      int x=1;\n   31      while (ndims--)\n   32:         x *= *dims++;\n   33      return x;\n   34  }\n   ..\n   86  \n   87      // take a real chunk of data, fft it and place the output at correct intervals\n   88:     for (k1=0;k1<dimOther;++k1) {\n   89          printf(\"Perform fft on %d\\n\", k1*dimReal);\n   90          kiss_fftr( st->cfg_r, timedata + k1*dimReal , tmp1 ); // tmp1 now holds nrbins complex points\n   91:         for (k2=0;k2<nrbins;++k2) {\n   92             tmp2[ k2*dimOther+k1 ] = tmp1[k2];\n   93             printf(\"Put %d -> %d*%d + %d == %d, %f %f\\n\", k2, k2, dimOther, k1, k2*dimOther + k1, tmp2[ k2*dimOther+k1 ].r, tmp2[ k2*dimOther+k1 ].i);\n   ..\n   95      }\n   96  \n   97:     for (k2=0;k2<nrbins;++k2) {\n   98          printf(\"Perform fft on %d\\n\", k2*dimOther);\n   99          kiss_fftnd(st->cfg_nd, tmp2+k2*dimOther, tmp1);  // tmp1 now holds dimOther complex points\n  100:         for (k1=0;k1<dimOther;++k1) {\n  101              freqdata[ k1*(nrbins) + k2] = tmp1[k1];\n  102              printf(\"And put %d -> %d*%d + %d == %d, %f %f\\n\", k1, k1, nrbins, k2, k1*(nrbins) + k2, freqdata[ k1*(nrbins) + k2].r, freqdata[ k1*(nrbins) + k2].i);\n  ...\n  114      kiss_fft_cpx * tmp2 = tmp1 + MAX(nrbins,dimOther);\n  115  \n  116:     for (k2=0;k2<nrbins;++k2) {\n  117:         for (k1=0;k1<dimOther;++k1)\n  118              tmp1[k1] = freqdata[ k1*(nrbins) + k2 ];\n  119          kiss_fftnd(st->cfg_nd, tmp1, tmp2+k2*dimOther);\n  120      }\n  121  \n  122:     for (k1=0;k1<dimOther;++k1) {\n  123:         for (k2=0;k2<nrbins;++k2)\n  124              tmp1[k2] = tmp2[ k2*dimOther+k1 ];\n  125          kiss_fftri( st->cfg_r,tmp1,timedata + k1*dimReal);\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/kiss_fft/kiss_fftr.c:\n   55      kiss_fft_alloc(nfft, inverse_fft, st->substate, &subsize);\n   56  \n   57:     for (i = 0; i < nfft/2; ++i) {\n   58          double phase =\n   59              -3.14159265358979323846264338327 * ((double) (i+1) / nfft + .5);\n   ..\n  103  #endif\n  104  \n  105:     for ( k=1;k <= ncfft/2 ; ++k ) {\n  106          fpk    = st->tmpbuf[k]; \n  107          fpnk.r =   st->tmpbuf[ncfft-k].r;\n  ...\n  137      C_FIXDIV(st->tmpbuf[0],2);\n  138  \n  139:     for (k = 1; k <= ncfft / 2; ++k) {\n  140          kiss_fft_cpx fk, fnkc, fek, fok, tmp;\n  141          fk = freqdata[k];\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/kiss_fft/kissfft.hh:\n   13      {\n   14          T_scalar phinc =  (inverse?2:-2)* acos( (T_scalar) -1)  / nfft;\n   15:         for (int i=0;i<nfft;++i)\n   16              dst[i] = exp( std::complex<T_scalar>(0,i*phinc) );\n   17      }\n   ..\n   87                      *Fout = *f;\n   88                      f += fstride*in_stride;\n   89:                 }while(++Fout != Fout_end );\n   90              }else{\n   91                  do{\n   ..\n  123          void kf_bfly2( cpx_type * Fout, const size_t fstride, int m)\n  124          {\n  125:             for (int k=0;k<m;++k) {\n  126                  cpx_type t = Fout[m+k] * _traits.twiddle(k*fstride);\n  127                  Fout[m+k] = Fout[k] - t;\n  ...\n  134              cpx_type scratch[7];\n  135              int negative_if_inverse = _inverse * -2 +1;\n  136:             for (size_t k=0;k<m;++k) {\n  137                  scratch[0] = Fout[k+m] * _traits.twiddle(k*fstride);\n  138                  scratch[1] = Fout[k+2*m] * _traits.twiddle(k*fstride*2);\n  ...\n  183  \n  184                  C_ADDTO( Fout[m] , cpx_type( -scratch[0].imag(),scratch[0].real() ) );\n  185:                 ++Fout;\n  186              }while(--k);\n  187          }\n  ...\n  205  \n  206              tw=twiddles;\n  207:             for ( u=0; u<m; ++u ) {\n  208                  C_FIXDIV( *Fout0,5); C_FIXDIV( *Fout1,5); C_FIXDIV( *Fout2,5); C_FIXDIV( *Fout3,5); C_FIXDIV( *Fout4,5);\n  209                  scratch[0] = *Fout0;\n  ...\n  249                  C_SUB(*Fout3,scratch[11],scratch[12]);\n  250  \n  251:                 ++Fout0;++Fout1;++Fout2;++Fout3;++Fout4;\n  252              }\n  253          }\n  ...\n  267              cpx_type scratchbuf[p];\n  268  \n  269:             for ( u=0; u<m; ++u ) {\n  270                  k=u;\n  271:                 for ( q1=0 ; q1<p ; ++q1 ) {\n  272                      scratchbuf[q1] = Fout[ k  ];\n  273                      C_FIXDIV(scratchbuf[q1],p);\n  ...\n  276  \n  277                  k=u;\n  278:                 for ( q1=0 ; q1<p ; ++q1 ) {\n  279                      int twidx=0;\n  280                      Fout[ k ] = scratchbuf[0];\n  281:                     for (q=1;q<p;++q ) {\n  282                          twidx += fstride * k;\n  283                          if (twidx>=Norig) twidx-=Norig;\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/pbjson/bin2ascii.h:\n   51  	std::string r;\n   52  	r.reserve(s.size() * 2);\n   53: 	for (size_t i = 0; i < s.size(); i++) {\n   54  		char hi = s[i] >> 4;\n   55  		char lo = s[i] & 0xf;\n   ..\n   82  		if (i + 2 < s.size()) r.push_back(lookup[n3]);\n   83  	}\n   84: 	for (int i = 0; i < (3 - s.size() % 3) % 3; i++)\n   85  		r.push_back('=');\n   86  	return r;\n   ..\n  113  		throw std::runtime_error(\"Invalid base64 data size\");\n  114  	size_t pad = 0;\n  115: 	if (s[s.size() - 1] == '=') pad++;\n  116: 	if (s[s.size() - 2] == '=') pad++;\n  117  \n  118  	r.reserve(s.size() * 3 / 4 + 3);\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/pbjson/pbjson.cpp:\n   63                  if (repeated)\n   64                  {\n   65:                     for (size_t i = 0; i != array_size; ++i)\n   66                      {\n   67                          double value = ref->GetRepeatedDouble(*msg, field, i);\n   ..\n   78                  if (repeated)\n   79                  {\n   80:                     for (size_t i = 0; i != array_size; ++i)\n   81                      {\n   82                          float value = ref->GetRepeatedFloat(*msg, field, i);\n   ..\n   93                  if (repeated)\n   94                  {\n   95:                     for (size_t i = 0; i != array_size; ++i)\n   96                      {\n   97                          int64_t value = ref->GetRepeatedInt64(*msg, field, i);\n   ..\n  108                  if (repeated)\n  109                  {\n  110:                     for (size_t i = 0; i != array_size; ++i)\n  111                      {\n  112                          uint64_t value = ref->GetRepeatedUInt64(*msg, field, i);\n  ...\n  123                  if (repeated)\n  124                  {\n  125:                     for (size_t i = 0; i != array_size; ++i)\n  126                      {\n  127                          int32_t value = ref->GetRepeatedInt32(*msg, field, i);\n  ...\n  138                  if (repeated)\n  139                  {\n  140:                     for (size_t i = 0; i != array_size; ++i)\n  141                      {\n  142                          uint32_t value = ref->GetRepeatedUInt32(*msg, field, i);\n  ...\n  153                  if (repeated)\n  154                  {\n  155:                     for (size_t i = 0; i != array_size; ++i)\n  156                      {\n  157                          bool value = ref->GetRepeatedBool(*msg, field, i);\n  ...\n  170                  if (repeated)\n  171                  {\n  172:                     for (size_t i = 0; i != array_size; ++i)\n  173                      {\n  174                          std::string value = ref->GetRepeatedString(*msg, field, i);\n  ...\n  195                  if (repeated)\n  196                  {\n  197:                     for (size_t i = 0; i != array_size; ++i)\n  198                      {\n  199                          const Message *value = &(ref->GetRepeatedMessage(*msg, field, i));\n  ...\n  212                  if (repeated)\n  213                  {\n  214:                     for (size_t i = 0; i != array_size; ++i)\n  215                      {\n  216                          const EnumValueDescriptor* value = ref->GetRepeatedEnum(*msg, field, i);\n  ...\n  239          if (!root)\n  240              return NULL;\n  241:         for (size_t i = 0; i != count; ++i)\n  242          {\n  243              const FieldDescriptor *field = d->field(i);\n  ...\n  464              RETURN_ERR(ERR_INVALID_PB, \"invalid pb object\");\n  465          }\n  466:         for (rapidjson::Value::ConstMemberIterator itr = json->MemberBegin(); itr != json->MemberEnd(); ++itr)\n  467          {\n  468              const char* name = itr->name.GetString();\n  ...\n  480                  if (itr->value.GetType() != rapidjson::kArrayType)\n  481                      RETURN_ERR(ERR_INVALID_JSON, \"Not array\");\n  482:                 for (rapidjson::Value::ConstValueIterator ait = itr->value.Begin(); ait != itr->value.End(); ++ait)\n  483                  {\n  484                      int ret = json2field(ait, msg, field, err);\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/rapidjson/document.h:\n   34  #elif defined(__GNUC__)\n   35  RAPIDJSON_DIAG_PUSH\n   36: RAPIDJSON_DIAG_OFF(effc++)\n   37  #endif\n   38  \n   ..\n   76  /*!\n   77      This class was internal to GenericValue. It used to be a inner struct.\n   78:     But a compiler (IBM XL C/C++ for AIX) have reported to have problem with that so it moved as a namespace scope struct.\n   79      https://code.google.com/p/rapidjson/issues/detail?id=64\n   80  */\n   ..\n   97  \n   98      This class implements a Random Access Iterator for GenericMember elements\n   99:     of a GenericValue, see ISO/IEC 14882:2003(E) C++ standard, 24.1 [lib.iterator.requirements].\n  100  \n  101      \\note This iterator implementation is mainly intended to avoid implicit\n  ...\n  105      \\note Define \\c RAPIDJSON_NOMEMBERITERATORCLASS to fall back to a\n  106          pointer-based implementation, if your platform doesn't provide\n  107:         the C++ <iterator> header.\n  108  \n  109      \\see GenericMember, GenericValue::MemberIterator, GenericValue::ConstMemberIterator\n  ...\n  162      //! @name stepping\n  163      //@{\n  164:     Iterator& operator++(){ ++ptr_; return *this; }\n  165      Iterator& operator--(){ --ptr_; return *this; }\n  166:     Iterator  operator++(int){ Iterator old(*this); ++ptr_; return old; }\n  167      Iterator  operator--(int){ Iterator old(*this); --ptr_; return old; }\n  168      //@}\n  ...\n  439  \n  440  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS\n  441:     //! Move constructor in C++11\n  442      GenericValue(GenericValue&& rhs) RAPIDJSON_NOEXCEPT : data_(rhs.data_), flags_(rhs.flags_) {\n  443          rhs.flags_ = kNullFlag; // give up contents\n  ...\n  564              switch(flags_) {\n  565              case kArrayFlag:\n  566:                 for (GenericValue* v = data_.a.elements; v != data_.a.elements + data_.a.size; ++v)\n  567                      v->~GenericValue();\n  568                  Allocator::Free(data_.a.elements);\n  ...\n  570  \n  571              case kObjectFlag:\n  572:                 for (MemberIterator m = MemberBegin(); m != MemberEnd(); ++m)\n  573                      m->~Member();\n  574                  Allocator::Free(data_.o.members);\n  ...\n  601  \n  602  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS\n  603:     //! Move assignment in C++11\n  604      GenericValue& operator=(GenericValue&& rhs) RAPIDJSON_NOEXCEPT {\n  605          return *this = rhs.Move();\n  ...\n  685              if (data_.o.size != rhs.data_.o.size)\n  686                  return false;           \n  687:             for (ConstMemberIterator lhsMemberItr = MemberBegin(); lhsMemberItr != MemberEnd(); ++lhsMemberItr) {\n  688                  typename RhsType::ConstMemberIterator rhsMemberItr = rhs.FindMember(lhsMemberItr->name);\n  689                  if (rhsMemberItr == rhs.MemberEnd() || lhsMemberItr->value != rhsMemberItr->value)\n  ...\n  695              if (data_.a.size != rhs.data_.a.size)\n  696                  return false;\n  697:             for (SizeType i = 0; i < data_.a.size; i++)\n  698                  if ((*this)[i] != rhs[i])\n  699                      return false;\n  ...\n  916          RAPIDJSON_ASSERT(name.IsString());\n  917          MemberIterator member = MemberBegin();\n  918:         for ( ; member != MemberEnd(); ++member)\n  919              if (name.StringEqual(member->name))\n  920                  break;\n  ...\n  951          o.members[o.size].name.RawAssign(name);\n  952          o.members[o.size].value.RawAssign(value);\n  953:         o.size++;\n  954          return *this;\n  955      }\n  ...\n 1032      void RemoveAllMembers() {\n 1033          RAPIDJSON_ASSERT(IsObject()); \n 1034:         for (MemberIterator m = MemberBegin(); m != MemberEnd(); ++m)\n 1035              m->~Member();\n 1036          data_.o.size = 0;\n ....\n 1119  \n 1120          MemberIterator pos = MemberBegin() + (first - MemberBegin());\n 1121:         for (MemberIterator itr = pos; itr != last; ++itr)\n 1122              itr->~Member();\n 1123          std::memmove(&*pos, &*last, (MemberEnd() - last) * sizeof(Member));\n ....\n 1150      void Clear() {\n 1151          RAPIDJSON_ASSERT(IsArray()); \n 1152:         for (SizeType i = 0; i < data_.a.size; ++i)\n 1153              data_.a.elements[i].~GenericValue();\n 1154          data_.a.size = 0;\n ....\n 1209          if (data_.a.size >= data_.a.capacity)\n 1210              Reserve(data_.a.capacity == 0 ? kDefaultArrayCapacity : (data_.a.capacity + (data_.a.capacity + 1) / 2), allocator);\n 1211:         data_.a.elements[data_.a.size++].RawAssign(value);\n 1212          return *this;\n 1213      }\n ....\n 1294          RAPIDJSON_ASSERT(last <= End());\n 1295          ValueIterator pos = Begin() + (first - Begin());\n 1296:         for (ValueIterator itr = pos; itr != last; ++itr)\n 1297              itr->~GenericValue();       \n 1298          std::memmove(pos, last, (End() - last) * sizeof(GenericValue));\n ....\n 1403              if (!handler.StartObject())\n 1404                  return false;\n 1405:             for (ConstMemberIterator m = MemberBegin(); m != MemberEnd(); ++m) {\n 1406                  RAPIDJSON_ASSERT(m->name.IsString()); // User may change the type of name by MemberIterator.\n 1407                  if (!handler.Key(m->name.GetString(), m->name.GetStringLength(), (m->name.flags_ & kCopyFlag) != 0))\n ....\n 1415              if (!handler.StartArray())\n 1416                  return false;\n 1417:             for (GenericValue* v = data_.a.elements; v != data_.a.elements + data_.a.size; ++v)\n 1418                  if (!v->Accept(handler))\n 1419                      return false;\n ....\n 1644  \n 1645  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS\n 1646:     //! Move constructor in C++11\n 1647      GenericDocument(GenericDocument&& rhs) RAPIDJSON_NOEXCEPT\n 1648          : ValueType(std::move(rhs)),\n ....\n 1663  \n 1664  #if RAPIDJSON_HAS_CXX11_RVALUE_REFS\n 1665:     //! Move assignment in C++11\n 1666      GenericDocument& operator=(GenericDocument&& rhs) RAPIDJSON_NOEXCEPT\n 1667      {\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/rapidjson/encodedstream.h:\n   26  #ifdef __GNUC__\n   27  RAPIDJSON_DIAG_PUSH\n   28: RAPIDJSON_DIAG_OFF(effc++)\n   29  #endif\n   30  \n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/rapidjson/encodings.h:\n   30  #elif defined(__GNUC__)\n   31  RAPIDJSON_DIAG_PUSH\n   32: RAPIDJSON_DIAG_OFF(effc++)\n   33  #endif\n   34  \n   ..\n  237  /*! http://en.wikipedia.org/wiki/UTF-16\n  238      http://tools.ietf.org/html/rfc2781\n  239:     \\tparam CharType Type for storing 16-bit UTF-16 data. Default is wchar_t. C++11 may use char16_t instead.\n  240      \\note implements Encoding concept\n  241  \n  ...\n  368  //! UTF-32 encoding. \n  369  /*! http://en.wikipedia.org/wiki/UTF-32\n  370:     \\tparam CharType Type for storing 32-bit UTF-32 data. Default is unsigned. C++11 may use char32_t instead.\n  371      \\note implements Encoding concept\n  372  \n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/rapidjson/filereadstream.h:\n   65      void Read() {\n   66          if (current_ < bufferLast_)\n   67:             ++current_;\n   68          else if (!eof_) {\n   69              count_ += readCount_;\n   ..\n   74              if (readCount_ < bufferSize_) {\n   75                  buffer_[readCount_] = '\\0';\n   76:                 ++bufferLast_;\n   77                  eof_ = true;\n   78              }\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/rapidjson/filestream.h:\n   58          if (c != EOF) {\n   59              current_ = (char)c;\n   60:             count_++;\n   61          }\n   62          else if (current_ != '\\0')\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/rapidjson/filewritestream.h:\n   43              Flush();\n   44  \n   45:         *current_++ = c;\n   46      }\n   47  \n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/rapidjson/memorystream.h:\n   44  \n   45      Ch Peek() const { return (src_ == end_) ? '\\0' : *src_; }\n   46:     Ch Take() { return (src_ == end_) ? '\\0' : *src_++; }\n   47      size_t Tell() const { return static_cast<size_t>(src_ - begin_); }\n   48  \n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/rapidjson/prettywriter.h:\n   26  #ifdef __GNUC__\n   27  RAPIDJSON_DIAG_PUSH\n   28: RAPIDJSON_DIAG_OFF(effc++)\n   29  #endif\n   30  \n   ..\n  181              if (!level->inArray && level->valueCount % 2 == 0)\n  182                  RAPIDJSON_ASSERT(type == kStringType);  // if it's in object, then even number should be a name\n  183:             level->valueCount++;\n  184          }\n  185          else {\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/rapidjson/rapidjson.h:\n  410  \n  411  ///////////////////////////////////////////////////////////////////////////////\n  412: // C++11 features\n  413  \n  414  #ifndef RAPIDJSON_HAS_CXX11_RVALUE_REFS\n  ...\n  532  template<typename Stream, typename Ch>\n  533  inline void PutN(Stream& stream, Ch c, size_t n) {\n  534:     for (size_t i = 0; i < n; i++)\n  535          stream.Put(c);\n  536  }\n  ...\n  549  \n  550      Ch Peek() const { return *src_; }\n  551:     Ch Take() { return *src_++; }\n  552      size_t Tell() const { return static_cast<size_t>(src_ - head_); }\n  553  \n  ...\n  584      // Read\n  585      Ch Peek() { return *src_; }\n  586:     Ch Take() { return *src_++; }\n  587      size_t Tell() { return static_cast<size_t>(src_ - head_); }\n  588  \n  589      // Write\n  590:     void Put(Ch c) { RAPIDJSON_ASSERT(dst_ != 0); *dst_++ = c; }\n  591  \n  592      Ch* PutBegin() { return dst_ = src_; }\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/rapidjson/reader.h:\n   48  #ifdef __GNUC__\n   49  RAPIDJSON_DIAG_PUSH\n   50: RAPIDJSON_DIAG_OFF(effc++)\n   51  #endif\n   52  \n   ..\n  264  	// Fast return for single non-whitespace\n  265  	if (*p == ' ' || *p == '\\n' || *p == '\\r' || *p == '\\t')\n  266: 		++p;\n  267  	else\n  268  		return p;\n  ...\n  272  	while (p != nextAligned)\n  273  		if (*p == ' ' || *p == '\\n' || *p == '\\r' || *p == '\\t')\n  274: 			++p;\n  275  		else\n  276  			return p;\n  ...\n  301  	// Fast return for single non-whitespace\n  302  	if (*p == ' ' || *p == '\\n' || *p == '\\r' || *p == '\\t')\n  303: 		++p;\n  304  	else\n  305  		return p;\n  ...\n  309  	while (p != nextAligned)\n  310  		if (*p == ' ' || *p == '\\n' || *p == '\\r' || *p == '\\t')\n  311: 			++p;\n  312  		else\n  313  			return p;\n  ...\n  506              SkipWhitespace(is);\n  507  \n  508:             ++memberCount;\n  509  \n  510              switch (is.Take()) {\n  ...\n  541              RAPIDJSON_PARSE_ERROR_EARLY_RETURN_VOID;\n  542  \n  543:             ++elementCount;\n  544              SkipWhitespace(is);\n  545  \n  ...\n  598      unsigned ParseHex4(InputStream& is) {\n  599          unsigned codepoint = 0;\n  600:         for (int i = 0; i < 4; i++) {\n  601              Ch c = is.Take();\n  602              codepoint <<= 4;\n  ...\n  624          RAPIDJSON_FORCEINLINE void Put(Ch c) {\n  625              *stack_.template Push<Ch>() = c;\n  626:             ++length_;\n  627          }\n  628          size_t Length() const { return length_; }\n  ...\n  807                      }\n  808                      i = i * 10 + static_cast<unsigned>(s.TakePush() - '0');\n  809:                     significandDigit++;\n  810                  }\n  811              else\n  ...\n  819                      }\n  820                      i = i * 10 + static_cast<unsigned>(s.TakePush() - '0');\n  821:                     significandDigit++;\n  822                  }\n  823          }\n  ...\n  838                          }\n  839                      i64 = i64 * 10 + static_cast<unsigned>(s.TakePush() - '0');\n  840:                     significandDigit++;\n  841                  }\n  842              else\n  ...\n  849                          }\n  850                      i64 = i64 * 10 + static_cast<unsigned>(s.TakePush() - '0');\n  851:                     significandDigit++;\n  852                  }\n  853          }\n  ...\n  885                          --expFrac;\n  886                          if (i64 != 0)\n  887:                             significandDigit++;\n  888                      }\n  889                  }\n  ...\n  902                      --expFrac;\n  903                      if (d != 0.0)\n  904:                         significandDigit++;\n  905                  }\n  906                  else\n  ...\n 1314              // If the object is not empty, count the last member.\n 1315              if (src == IterativeParsingMemberValueState)\n 1316:                 ++c;\n 1317              // Restore the state.\n 1318              IterativeParsingState n = static_cast<IterativeParsingState>(*stack_.template Pop<SizeType>(1));\n ....\n 1339              // If the array is not empty, count the last element.\n 1340              if (src == IterativeParsingElementState)\n 1341:                 ++c;\n 1342              // Restore the state.\n 1343              IterativeParsingState n = static_cast<IterativeParsingState>(*stack_.template Pop<SizeType>(1));\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/rapidjson/writer.h:\n  211          char buffer[11];\n  212          const char* end = internal::i32toa(i, buffer);\n  213:         for (const char* p = buffer; p != end; ++p)\n  214              os_->Put(*p);\n  215          return true;\n  ...\n  219          char buffer[10];\n  220          const char* end = internal::u32toa(u, buffer);\n  221:         for (const char* p = buffer; p != end; ++p)\n  222              os_->Put(*p);\n  223          return true;\n  ...\n  227          char buffer[21];\n  228          const char* end = internal::i64toa(i64, buffer);\n  229:         for (const char* p = buffer; p != end; ++p)\n  230              os_->Put(*p);\n  231          return true;\n  ...\n  235          char buffer[20];\n  236          char* end = internal::u64toa(u64, buffer);\n  237:         for (char* p = buffer; p != end; ++p)\n  238              os_->Put(*p);\n  239          return true;\n  ...\n  243          char buffer[25];\n  244          char* end = internal::dtoa(d, buffer);\n  245:         for (char* p = buffer; p != end; ++p)\n  246              os_->Put(*p);\n  247          return true;\n  ...\n  333              if (!level->inArray && level->valueCount % 2 == 0)\n  334                  RAPIDJSON_ASSERT(type == kStringType);  // if it's in object, then even number should be a name\n  335:             level->valueCount++;\n  336          }\n  337          else {\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/rapidjson/internal/biginteger.h:\n   67          Type backup = digits_[0];\n   68          digits_[0] += u;\n   69:         for (size_t i = 0; i < count_ - 1; i++) {\n   70              if (digits_[i] >= backup)\n   71                  return *this; // no carry\n   ..\n   87  \n   88          uint64_t k = 0;\n   89:         for (size_t i = 0; i < count_; i++) {\n   90              uint64_t hi;\n   91              digits_[i] = MulAdd64(digits_[i], u, k, &hi);\n   ..\n  105  \n  106          uint32_t k = 0;\n  107:         for (size_t i = 0; i < count_; i++) {\n  108              const uint64_t c = digits_[i] >> 32;\n  109              const uint64_t d = digits_[i] & 0xFFFFFFFF;\n  ...\n  140              count_ += offset;\n  141              if (digits_[count_])\n  142:                 count_++;\n  143          }\n  144  \n  ...\n  192  \n  193          Type borrow = 0;\n  194:         for (size_t i = 0; i < a->count_; i++) {\n  195              Type d = a->digits_[i] - borrow;\n  196              if (i < b->count_)\n  ...\n  233      void PushBack(Type digit) {\n  234          RAPIDJSON_ASSERT(count_ < kCapacity);\n  235:         digits_[count_++] = digit;\n  236      }\n  237  \n  238      static uint64_t ParseUint64(const char* begin, const char* end) {\n  239          uint64_t r = 0;\n  240:         for (const char* p = begin; p != end; ++p) {\n  241              RAPIDJSON_ASSERT(*p >= '0' && *p <= '9');\n  242              r = r * 10 + (*p - '0');\n  ...\n  250          uint64_t low = _umul128(a, b, outHigh) + k;\n  251          if (low < k)\n  252:             (*outHigh)++;\n  253          return low;\n  254  #elif (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)) && defined(__x86_64__)\n  ...\n  269          lo += k;\n  270          if (lo < k)\n  271:             hi++;\n  272          *outHigh = hi;\n  273          return lo;\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/rapidjson/internal/diyfp.h:\n   19  // THE SOFTWARE.\n   20  \n   21: // This is a C++ header-only implementation of Grisu2 algorithm from the publication:\n   22  // Loitsch, Florian. \"Printing floating-point numbers quickly and accurately with\n   23  // integers.\" ACM Sigplan Notices 45.6 (2010): 233-243.\n   ..\n   38  #ifdef __GNUC__\n   39  RAPIDJSON_DIAG_PUSH\n   40: RAPIDJSON_DIAG_OFF(effc++)\n   41  #endif\n   42  \n   ..\n   73          uint64_t l = _umul128(f, rhs.f, &h);\n   74          if (l & (uint64_t(1) << 63)) // rounding\n   75:             h++;\n   76          return DiyFp(h, e + rhs.e + 64);\n   77  #elif (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 6)) && defined(__x86_64__)\n   ..\n   80          uint64_t l = static_cast<uint64_t>(p);\n   81          if (l & (uint64_t(1) << 63)) // rounding\n   82:             h++;\n   83          return DiyFp(h, e + rhs.e + 64);\n   84  #else\n   ..\n  145          while (significand > kDpHiddenBit + kDpSignificandMask) {\n  146              significand >>= 1;\n  147:             exponent++;\n  148          }\n  149          while (exponent > kDpDenormalExponent && (significand & kDpHiddenBit) == 0) {\n  ...\n  245      int k = static_cast<int>(dk);\n  246      if (k != dk)\n  247:         k++;\n  248  \n  249      unsigned index = static_cast<unsigned>((k >> 3) + 1);\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/rapidjson/internal/dtoa.h:\n   19  // THE SOFTWARE.\n   20  \n   21: // This is a C++ header-only implementation of Grisu2 algorithm from the publication:\n   22  // Loitsch, Florian. \"Printing floating-point numbers quickly and accurately with\n   23  // integers.\" ACM Sigplan Notices 45.6 (2010): 233-243.\n   ..\n   34  #ifdef __GNUC__\n   35  RAPIDJSON_DIAG_PUSH\n   36: RAPIDJSON_DIAG_OFF(effc++)\n   37  #endif\n   38  \n   ..\n   47  \n   48  inline unsigned CountDecimalDigit32(uint32_t n) {\n   49:     // Simple pure C++ implementation was faster than __builtin_clz version in this situation.\n   50      if (n < 10) return 1;\n   51      if (n < 100) return 2;\n   ..\n   92          }\n   93          if (d || *len)\n   94:             buffer[(*len)++] = static_cast<char>('0' + static_cast<char>(d));\n   95          kappa--;\n   96          uint64_t tmp = (static_cast<uint64_t>(p1) << -one.e) + p2;\n   ..\n  108          char d = static_cast<char>(p2 >> -one.e);\n  109          if (d || *len)\n  110:             buffer[(*len)++] = static_cast<char>('0' + d);\n  111          p2 &= one.f - 1;\n  112          kappa--;\n  ...\n  128      DiyFp Wp = w_p * c_mk;\n  129      DiyFp Wm = w_m * c_mk;\n  130:     Wm.f++;\n  131      Wp.f--;\n  132      DigitGen(W, Wp, Wp.f - Wm.f, buffer, length, K);\n  ...\n  135  inline char* WriteExponent(int K, char* buffer) {\n  136      if (K < 0) {\n  137:         *buffer++ = '-';\n  138          K = -K;\n  139      }\n  140  \n  141      if (K >= 100) {\n  142:         *buffer++ = static_cast<char>('0' + static_cast<char>(K / 100));\n  143          K %= 100;\n  144          const char* d = GetDigitsLut() + K * 2;\n  145:         *buffer++ = d[0];\n  146:         *buffer++ = d[1];\n  147      }\n  148      else if (K >= 10) {\n  149          const char* d = GetDigitsLut() + K * 2;\n  150:         *buffer++ = d[0];\n  151:         *buffer++ = d[1];\n  152      }\n  153      else\n  154:         *buffer++ = static_cast<char>('0' + static_cast<char>(K));\n  155  \n  156      return buffer;\n  ...\n  162      if (length <= kk && kk <= 21) {\n  163          // 1234e7 -> 12340000000\n  164:         for (int i = length; i < kk; i++)\n  165              buffer[i] = '0';\n  166          buffer[kk] = '.';\n  ...\n  180          buffer[0] = '0';\n  181          buffer[1] = '.';\n  182:         for (int i = 2; i < offset; i++)\n  183              buffer[i] = '0';\n  184          return &buffer[length + offset];\n  ...\n  207      else {\n  208          if (value < 0) {\n  209:             *buffer++ = '-';\n  210              value = -value;\n  211          }\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/rapidjson/internal/itoa.h:\n   49          \n   50          if (value >= 1000)\n   51:             *buffer++ = cDigitsLut[d1];\n   52          if (value >= 100)\n   53:             *buffer++ = cDigitsLut[d1 + 1];\n   54          if (value >= 10)\n   55:             *buffer++ = cDigitsLut[d2];\n   56:         *buffer++ = cDigitsLut[d2 + 1];\n   57      }\n   58      else if (value < 100000000) {\n   ..\n   68          \n   69          if (value >= 10000000)\n   70:             *buffer++ = cDigitsLut[d1];\n   71          if (value >= 1000000)\n   72:             *buffer++ = cDigitsLut[d1 + 1];\n   73          if (value >= 100000)\n   74:             *buffer++ = cDigitsLut[d2];\n   75:         *buffer++ = cDigitsLut[d2 + 1];\n   76          \n   77:         *buffer++ = cDigitsLut[d3];\n   78:         *buffer++ = cDigitsLut[d3 + 1];\n   79:         *buffer++ = cDigitsLut[d4];\n   80:         *buffer++ = cDigitsLut[d4 + 1];\n   81      }\n   82      else {\n   ..\n   88          if (a >= 10) {\n   89              const unsigned i = a << 1;\n   90:             *buffer++ = cDigitsLut[i];\n   91:             *buffer++ = cDigitsLut[i + 1];\n   92          }\n   93          else\n   94:             *buffer++ = static_cast<char>('0' + static_cast<char>(a));\n   95  \n   96          const uint32_t b = value / 10000; // 0 to 9999\n   ..\n  103          const uint32_t d4 = (c % 100) << 1;\n  104          \n  105:         *buffer++ = cDigitsLut[d1];\n  106:         *buffer++ = cDigitsLut[d1 + 1];\n  107:         *buffer++ = cDigitsLut[d2];\n  108:         *buffer++ = cDigitsLut[d2 + 1];\n  109:         *buffer++ = cDigitsLut[d3];\n  110:         *buffer++ = cDigitsLut[d3 + 1];\n  111:         *buffer++ = cDigitsLut[d4];\n  112:         *buffer++ = cDigitsLut[d4 + 1];\n  113      }\n  114      return buffer;\n  ...\n  117  inline char* i32toa(int32_t value, char* buffer) {\n  118      if (value < 0) {\n  119:         *buffer++ = '-';\n  120          value = -value;\n  121      }\n  ...\n  143              \n  144              if (v >= 1000)\n  145:                 *buffer++ = cDigitsLut[d1];\n  146              if (v >= 100)\n  147:                 *buffer++ = cDigitsLut[d1 + 1];\n  148              if (v >= 10)\n  149:                 *buffer++ = cDigitsLut[d2];\n  150:             *buffer++ = cDigitsLut[d2 + 1];\n  151          }\n  152          else {\n  ...\n  162              \n  163              if (value >= 10000000)\n  164:                 *buffer++ = cDigitsLut[d1];\n  165              if (value >= 1000000)\n  166:                 *buffer++ = cDigitsLut[d1 + 1];\n  167              if (value >= 100000)\n  168:                 *buffer++ = cDigitsLut[d2];\n  169:             *buffer++ = cDigitsLut[d2 + 1];\n  170              \n  171:             *buffer++ = cDigitsLut[d3];\n  172:             *buffer++ = cDigitsLut[d3 + 1];\n  173:             *buffer++ = cDigitsLut[d4];\n  174:             *buffer++ = cDigitsLut[d4 + 1];\n  175          }\n  176      }\n  ...\n  198  \n  199          if (value >= kTen15)\n  200:             *buffer++ = cDigitsLut[d1];\n  201          if (value >= kTen14)\n  202:             *buffer++ = cDigitsLut[d1 + 1];\n  203          if (value >= kTen13)\n  204:             *buffer++ = cDigitsLut[d2];\n  205          if (value >= kTen12)\n  206:             *buffer++ = cDigitsLut[d2 + 1];\n  207          if (value >= kTen11)\n  208:             *buffer++ = cDigitsLut[d3];\n  209          if (value >= kTen10)\n  210:             *buffer++ = cDigitsLut[d3 + 1];\n  211          if (value >= kTen9)\n  212:             *buffer++ = cDigitsLut[d4];\n  213          if (value >= kTen8)\n  214:             *buffer++ = cDigitsLut[d4 + 1];\n  215          \n  216:         *buffer++ = cDigitsLut[d5];\n  217:         *buffer++ = cDigitsLut[d5 + 1];\n  218:         *buffer++ = cDigitsLut[d6];\n  219:         *buffer++ = cDigitsLut[d6 + 1];\n  220:         *buffer++ = cDigitsLut[d7];\n  221:         *buffer++ = cDigitsLut[d7 + 1];\n  222:         *buffer++ = cDigitsLut[d8];\n  223:         *buffer++ = cDigitsLut[d8 + 1];\n  224      }\n  225      else {\n  ...\n  228          \n  229          if (a < 10)\n  230:             *buffer++ = static_cast<char>('0' + static_cast<char>(a));\n  231          else if (a < 100) {\n  232              const uint32_t i = a << 1;\n  233:             *buffer++ = cDigitsLut[i];\n  234:             *buffer++ = cDigitsLut[i + 1];\n  235          }\n  236          else if (a < 1000) {\n  237:             *buffer++ = static_cast<char>('0' + static_cast<char>(a / 100));\n  238              \n  239              const uint32_t i = (a % 100) << 1;\n  240:             *buffer++ = cDigitsLut[i];\n  241:             *buffer++ = cDigitsLut[i + 1];\n  242          }\n  243          else {\n  244              const uint32_t i = (a / 100) << 1;\n  245              const uint32_t j = (a % 100) << 1;\n  246:             *buffer++ = cDigitsLut[i];\n  247:             *buffer++ = cDigitsLut[i + 1];\n  248:             *buffer++ = cDigitsLut[j];\n  249:             *buffer++ = cDigitsLut[j + 1];\n  250          }\n  251          \n  ...\n  271          const uint32_t d8 = (c1 % 100) << 1;\n  272          \n  273:         *buffer++ = cDigitsLut[d1];\n  274:         *buffer++ = cDigitsLut[d1 + 1];\n  275:         *buffer++ = cDigitsLut[d2];\n  276:         *buffer++ = cDigitsLut[d2 + 1];\n  277:         *buffer++ = cDigitsLut[d3];\n  278:         *buffer++ = cDigitsLut[d3 + 1];\n  279:         *buffer++ = cDigitsLut[d4];\n  280:         *buffer++ = cDigitsLut[d4 + 1];\n  281:         *buffer++ = cDigitsLut[d5];\n  282:         *buffer++ = cDigitsLut[d5 + 1];\n  283:         *buffer++ = cDigitsLut[d6];\n  284:         *buffer++ = cDigitsLut[d6 + 1];\n  285:         *buffer++ = cDigitsLut[d7];\n  286:         *buffer++ = cDigitsLut[d7 + 1];\n  287:         *buffer++ = cDigitsLut[d8];\n  288:         *buffer++ = cDigitsLut[d8 + 1];\n  289      }\n  290      \n  ...\n  294  inline char* i64toa(int64_t value, char* buffer) {\n  295      if (value < 0) {\n  296:         *buffer++ = '-';\n  297          value = -value;\n  298      }\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/rapidjson/internal/meta.h:\n   28  #ifdef __GNUC__\n   29  RAPIDJSON_DIAG_PUSH\n   30: RAPIDJSON_DIAG_OFF(effc++)\n   31  #endif\n   32  #if defined(_MSC_VER)\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/rapidjson/internal/strfunc.h:\n   34  inline SizeType StrLen(const Ch* s) {\n   35      const Ch* p = s;\n   36:     while (*p) ++p;\n   37      return SizeType(p - s);\n   38  }\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/rapidjson/internal/strtod.h:\n  147      uint64_t significand = 0;\n  148      size_t i = 0;   // 2^64 - 1 = 18446744073709551615, 1844674407370955161 = 0x1999999999999999    \n  149:     for (; i < length; i++) {\n  150          if (significand  >  RAPIDJSON_UINT64_C2(0x19999999, 0x99999999) ||\n  151              (significand == RAPIDJSON_UINT64_C2(0x19999999, 0x99999999) && decimals[i] > '5'))\n  ...\n  155      \n  156      if (i < length && decimals[i] >= '5') // Rounding\n  157:         significand++;\n  158  \n  159      size_t remaining = length - i;\n  ...\n  209      const uint64_t halfWay = (uint64_t(1) << (precisionSize - 1)) * kUlp;\n  210      if (precisionBits >= halfWay + error)\n  211:         rounded.f++;\n  212  \n  213      *result = rounded.ToDouble();\n  ...\n  220      const int dExp = (int)decimalPosition - (int)length + exp;\n  221      Double a(approx);\n  222:     for (int i = 0; i < 10; i++) {\n  223          bool adjustToNegative;\n  224          int cmp = CheckWithinHalfULP(a.Value(), dInt, dExp, &adjustToNegative);\n  ...\n  251      while (*decimals == '0' && length > 1) {\n  252          length--;\n  253:         decimals++;\n  254          decimalPosition--;\n  255      }\n  ...\n  259          length--;\n  260          decimalPosition--;\n  261:         exp++;\n  262      }\n  263  \n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/rapidjson/msinttypes/inttypes.h:\n   32  \n   33  #ifndef _MSC_VER // [\n   34: #error \"Use this header only with Microsoft Visual C++ compilers!\"\n   35  #endif // _MSC_VER ]\n   36  \n   ..\n  293     if (numer < 0 && result.rem > 0) {\n  294        // did division wrong; must fix up\n  295:       ++result.quot;\n  296        result.rem -= denom;\n  297     }\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/rapidjson/msinttypes/stdint.h:\n   32  \n   33  #ifndef _MSC_VER // [\n   34: #error \"Use this header only with Microsoft Visual C++ compilers!\"\n   35  #endif // _MSC_VER ]\n   36  \n   ..\n   85  #include <limits.h>\n   86  \n   87: // For Visual Studio 6 in C++ mode and for many Visual Studio versions when\n   88: // compiling for ARM we should wrap <wchar.h> include with 'extern \"C++\" {}'\n   89  // or compiler give many errors like this:\n   90  //   error C2733: second C linkage of overloaded function 'wmemchr' not allowed\n   ..\n  111  // 7.18.1.1 Exact-width integer types\n  112  \n  113: // Visual Studio 6 and Embedded Visual C++ 4 doesn't\n  114  // realize that, e.g. char has the same size as __int8\n  115  // so we give up on __intX for them.\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/async_logger.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/common.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/formatter.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/logger.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/spdlog.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/tweakme.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/details/async_log_helper.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/details/async_logger_impl.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/details/file_helper.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n    .\n   69          const tchar* mode = truncate ? S(\"wb\") : S(\"ab\");\n   70          _filename = fname;\n   71:         for (int tries = 0; tries < open_tries; ++tries)\n   72          {\n   73              if(!os::fopen_s(&_fd, fname, mode))\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/details/format.cc:\n    1  /*\n    2: Formatting library for C++\n    3  \n    4  Copyright (c) 2012 - 2015, Victor Zverovich\n    .\n  263      unsigned value = 0;\n  264      do {\n  265:         unsigned new_value = value * 10 + (*s++ - '0');\n  266          // Check if value wrapped around.\n  267          if (new_value < value) {\n  ...\n  297                                         \"format specifier '{}' requires signed argument\", sign)));\n  298      }\n  299:     ++s;\n  300  }\n  301  \n  ...\n  615      FMT_POWERS_OF_10(fmt::ULongLong(1000000000)),\n  616      // Multiply several constants instead of using a single long long constant\n  617:     // to avoid warnings about C++98 not supporting long long.\n  618      fmt::ULongLong(1000000000) * fmt::ULongLong(1000000000) * 10\n  619  };\n  ...\n  740          args.type(ArgList::MAX_PACKED_ARGS - 1) == internal::Arg::NONE;\n  741      if (use_values) {\n  742:         for (unsigned i = 0;/*nothing*/; ++i) {\n  743              internal::Arg::Type arg_type = args.type(i);\n  744              switch (arg_type) {\n  ...\n  756          return;\n  757      }\n  758:     for (unsigned i = 0; i != ArgList::MAX_PACKED_ARGS; ++i) {\n  759          internal::Arg::Type arg_type = args.type(i);\n  760          if (arg_type == internal::Arg::NAMED_ARG) {\n  ...\n  763          }\n  764      }\n  765:     for (unsigned i = ArgList::MAX_PACKED_ARGS;/*nothing*/; ++i) {\n  766          switch (args.args_[i].type) {\n  767          case internal::Arg::NONE:\n  ...\n  836      Char c;\n  837      do {\n  838:         c = *++s;\n  839      } while (is_name_start(c) || ('0' <= c && c <= '9'));\n  840      const char *error = 0;\n  ...\n  863  inline Arg fmt::internal::FormatterBase::next_arg(const char *&error) {\n  864      if (next_arg_index_ >= 0)\n  865:         return do_get_arg(next_arg_index_++, error);\n  866      error = \"cannot switch from manual to automatic argument indexing\";\n  867      return Arg();\n  ...\n  887      FormatSpec &spec, const Char *&s) {\n  888      for (;;) {\n  889:         switch (*s++) {\n  890          case '-':\n  891              spec.align_ = ALIGN_LEFT;\n  ...\n  932          unsigned value = parse_nonnegative_int(s);\n  933          if (*s == '$') {  // value is an argument index\n  934:             ++s;\n  935              arg_index = value;\n  936          }\n  ...\n  952      }\n  953      else if (*s == '*') {\n  954:         ++s;\n  955          spec.width_ = WidthHandler(spec).visit(get_arg(s));\n  956      }\n  ...\n  966      const Char *s = start;\n  967      while (*s) {\n  968:         Char c = *s++;\n  969          if (c != '%') continue;\n  970          if (*s == c) {\n  971              write(writer, start, s);\n  972:             start = ++s;\n  973              continue;\n  974          }\n  ...\n  983          // Parse precision.\n  984          if (*s == '.') {\n  985:             ++s;\n  986              if ('0' <= *s && *s <= '9') {\n  987                  spec.precision_ = parse_nonnegative_int(s);\n  988              }\n  989              else if (*s == '*') {\n  990:                 ++s;\n  991                  spec.precision_ = PrecisionHandler().visit(get_arg(s));\n  992              }\n  ...\n 1004  \n 1005          // Parse length and convert the argument to the required type.\n 1006:         switch (*s++) {\n 1007          case 'h':\n 1008              if (*s == 'h')\n 1009:                 ArgConverter<signed char>(arg, *++s).visit(arg);\n 1010              else\n 1011                  ArgConverter<short>(arg, *s).visit(arg);\n ....\n 1013          case 'l':\n 1014              if (*s == 'l')\n 1015:                 ArgConverter<fmt::LongLong>(arg, *++s).visit(arg);\n 1016              else\n 1017                  ArgConverter<long>(arg, *s).visit(arg);\n ....\n 1038          if (!*s)\n 1039              FMT_THROW(FormatError(\"invalid format string\"));\n 1040:         spec.type_ = static_cast<char>(*s++);\n 1041          if (arg.type <= Arg::LAST_INTEGER_TYPE) {\n 1042              // Normalize type.\n ....\n 1071              return s;\n 1072          }\n 1073:         ++s;\n 1074          // Parse fill and alignment.\n 1075          if (Char c = *s) {\n ....\n 1099                          spec.fill_ = c;\n 1100                      }\n 1101:                     else ++s;\n 1102                      if (spec.align_ == ALIGN_NUMERIC)\n 1103                          require_numeric_argument(arg, '=');\n ....\n 1126              require_numeric_argument(arg, '#');\n 1127              spec.flags_ |= HASH_FLAG;\n 1128:             ++s;\n 1129          }\n 1130  \n ....\n 1134              spec.align_ = ALIGN_NUMERIC;\n 1135              spec.fill_ = '0';\n 1136:             ++s;\n 1137          }\n 1138  \n ....\n 1142          }\n 1143          else if (*s == '{') {\n 1144:             ++s;\n 1145              Arg width_arg = is_name_start(*s) ?\n 1146                              parse_arg_name(s) : parse_arg_index(s);\n 1147:             if (*s++ != '}')\n 1148                  FMT_THROW(FormatError(\"invalid format string\"));\n 1149              ULongLong value = 0;\n ....\n 1175          // Parse precision.\n 1176          if (*s == '.') {\n 1177:             ++s;\n 1178              spec.precision_ = 0;\n 1179              if ('0' <= *s && *s <= '9') {\n ....\n 1181              }\n 1182              else if (*s == '{') {\n 1183:                 ++s;\n 1184                  Arg precision_arg =\n 1185                      is_name_start(*s) ? parse_arg_name(s) : parse_arg_index(s);\n 1186:                 if (*s++ != '}')\n 1187                      FMT_THROW(FormatError(\"invalid format string\"));\n 1188                  ULongLong value = 0;\n ....\n 1223          // Parse type.\n 1224          if (*s != '}' && *s)\n 1225:             spec.type_ = static_cast<char>(*s++);\n 1226      }\n 1227  \n 1228:     if (*s++ != '}')\n 1229          FMT_THROW(FormatError(\"missing '}' in format string\"));\n 1230      start_ = s;\n ....\n 1241      set_args(args);\n 1242      while (*s) {\n 1243:         Char c = *s++;\n 1244          if (c != '{' && c != '}') continue;\n 1245          if (*s == c) {\n 1246              write(writer_, start_, s);\n 1247:             start_ = ++s;\n 1248              continue;\n 1249          }\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/details/format.h:\n    1  /*\n    2: Formatting library for C++\n    3  \n    4  Copyright (c) 2012 - 2015, Victor Zverovich\n    .\n  132  #ifndef FMT_USE_VARIADIC_TEMPLATES\n  133  // Variadic templates are available in GCC since version 4.4\n  134: // (http://gcc.gnu.org/projects/cxx0x.html) and in Visual C++\n  135  // since version 2013.\n  136  # define FMT_USE_VARIADIC_TEMPLATES \\\n  ...\n  140  \n  141  #ifndef FMT_USE_RVALUE_REFERENCES\n  142: // Don't use rvalue references when compiling with clang and an old libstdc++\n  143  // as the latter doesn't provide std::move.\n  144  # if defined(FMT_GNUC_LIBSTD_VERSION) && FMT_GNUC_LIBSTD_VERSION <= 402\n  ...\n  155  #endif\n  156  \n  157: // Define FMT_USE_NOEXCEPT to make C++ Format use noexcept (C++11 feature).\n  158  #ifndef FMT_NOEXCEPT\n  159  # if FMT_USE_NOEXCEPT || FMT_HAS_FEATURE(cxx_noexcept) || \\\n  ...\n  434          if (size_ == capacity_)\n  435              grow(size_ + 1);\n  436:         ptr_[size_++] = value;\n  437      }\n  438  \n  ...\n  555  // Portable version of signbit.\n  556  inline int getsign(double x) {\n  557:     // When compiled in C++11 mode signbit is no longer a macro but a function\n  558      // defined in namespace std and the macro is undefined.\n  559  # ifdef signbit\n  ...\n  742          // Integer division is slow so do it for a group of four digits instead\n  743          // of for every digit. The idea comes from the talk by Alexandrescu\n  744:         // \"Three Optimization Tips for C++\". See speed-test for a comparison.\n  745          if (n < 10) return count;\n  746          if (n < 100) return count + 1;\n  ...\n  768          // Integer division is slow so do it for a group of two digits instead\n  769          // of for every digit. The idea comes from the talk by Alexandrescu\n  770:         // \"Three Optimization Tips for C++\". See speed-test for a comparison.\n  771          unsigned index = (value % 100) * 2;\n  772          value /= 100;\n  ...\n 1322              return arg;\n 1323          }\n 1324:         for (unsigned i = MAX_PACKED_ARGS; i <= index; ++i) {\n 1325              if (args_[i].type == Arg::NONE)\n 1326                  return args_[i];\n ....\n 1642  /* one that takes a fill character and one that doesn't. In the future this */ \\\n 1643  /* can be replaced with one overload making the template argument Char      */ \\\n 1644: /* default to char (C++11). */ \\\n 1645  template <char TYPE_CODE, typename Char> \\\n 1646  inline IntFormatSpec<TYPE, AlignTypeSpec<TYPE_CODE>, Char> pad( \\\n ....\n 1841        }\n 1842  \n 1843: // Emulates a variadic function returning void on a pre-C++11 compiler.\n 1844  # define FMT_VARIADIC_VOID(func, arg_type) \\\n 1845    inline void func(arg_type arg) { func(arg, fmt::ArgList()); } \\\n ....\n 1858        }\n 1859  \n 1860: // Emulates a variadic constructor on a pre-C++11 compiler.\n 1861  # define FMT_VARIADIC_CTOR(ctor, func, arg0_type, arg1_type) \\\n 1862    FMT_CTOR(ctor, func, arg0_type, arg1_type, 1) \\\n ....\n 2038      // The second argument is only used for overload resolution.\n 2039      void append_float_length(Char *&format_ptr, long double) {\n 2040:         *format_ptr++ = 'L';\n 2041      }\n 2042  \n ....\n 2334      if (internal::is_negative(value)) {\n 2335          prefix[0] = '-';\n 2336:         ++prefix_size;\n 2337          abs_value = 0 - abs_value;\n 2338      }\n 2339      else if (spec.flag(SIGN_FLAG)) {\n 2340          prefix[0] = spec.flag(PLUS_FLAG) ? '+' : ' ';\n 2341:         ++prefix_size;\n 2342      }\n 2343      switch (spec.type()) {\n ....\n 2354          UnsignedType n = abs_value;\n 2355          if (spec.flag(HASH_FLAG)) {\n 2356:             prefix[prefix_size++] = '0';\n 2357:             prefix[prefix_size++] = spec.type();\n 2358          }\n 2359          unsigned num_digits = 0;\n 2360          do {\n 2361:             ++num_digits;\n 2362          } while ((n >>= 4) != 0);\n 2363          Char *p = get(prepare_int_buffer(\n ....\n 2375          UnsignedType n = abs_value;\n 2376          if (spec.flag(HASH_FLAG)) {\n 2377:             prefix[prefix_size++] = '0';\n 2378:             prefix[prefix_size++] = spec.type();\n 2379          }\n 2380          unsigned num_digits = 0;\n 2381          do {\n 2382:             ++num_digits;\n 2383          } while ((n >>= 1) != 0);\n 2384          Char *p = get(prepare_int_buffer(num_digits, spec, prefix, prefix_size));\n ....\n 2392          UnsignedType n = abs_value;\n 2393          if (spec.flag(HASH_FLAG))\n 2394:             prefix[prefix_size++] = '0';\n 2395          unsigned num_digits = 0;\n 2396          do {\n 2397:             ++num_digits;\n 2398          } while ((n >>= 3) != 0);\n 2399          Char *p = get(prepare_int_buffer(num_digits, spec, prefix, prefix_size));\n ....\n 2461          if (!sign) {\n 2462              --nan_size;\n 2463:             ++nan;\n 2464          }\n 2465          CharPtr out = write_str(nan, nan_size, spec);\n ....\n 2476          if (!sign) {\n 2477              --inf_size;\n 2478:             ++inf;\n 2479          }\n 2480          CharPtr out = write_str(inf, inf_size, spec);\n ....\n 2490          if (width > 0)\n 2491              --width;\n 2492:         ++offset;\n 2493      }\n 2494  \n ....\n 2497      Char format[MAX_FORMAT_SIZE];\n 2498      Char *format_ptr = format;\n 2499:     *format_ptr++ = '%';\n 2500      unsigned width_for_sprintf = width;\n 2501      if (spec.flag(HASH_FLAG))\n 2502:         *format_ptr++ = '#';\n 2503      if (spec.align() == ALIGN_CENTER) {\n 2504          width_for_sprintf = 0;\n ....\n 2506      else {\n 2507          if (spec.align() == ALIGN_LEFT)\n 2508:             *format_ptr++ = '-';\n 2509          if (width != 0)\n 2510:             *format_ptr++ = '*';\n 2511      }\n 2512      if (spec.precision() >= 0) {\n 2513:         *format_ptr++ = '.';\n 2514:         *format_ptr++ = '*';\n 2515      }\n 2516  \n 2517      append_float_length(format_ptr, value);\n 2518:     *format_ptr++ = type;\n 2519      *format_ptr = '\\0';\n 2520  \n ....\n 2545                      *(start - 1) = fill;\n 2546                  }\n 2547:                 ++n;\n 2548              }\n 2549              if (spec.align() == ALIGN_CENTER &&\n ....\n 2557              if (spec.fill() != ' ' || sign) {\n 2558                  while (*start == ' ')\n 2559:                     *start++ = fill;\n 2560                  if (sign)\n 2561                      *(start - 1) = sign;\n ....\n 2883              // Integer division is slow so do it for a group of two digits instead\n 2884              // of for every digit. The idea comes from the talk by Alexandrescu\n 2885:             // \"Three Optimization Tips for C++\". See speed-test for a comparison.\n 2886              unsigned index = (value % 100) * 2;\n 2887              value /= 100;\n ....\n 2964      typename internal::IntTraits<T>::MainType abs_value = value;\n 2965      if (internal::is_negative(value)) {\n 2966:         *buffer++ = '-';\n 2967          abs_value = 0 - abs_value;\n 2968      }\n 2969      if (abs_value < 100) {\n 2970          if (abs_value < 10) {\n 2971:             *buffer++ = static_cast<char>('0' + abs_value);\n 2972              return;\n 2973          }\n 2974          unsigned index = static_cast<unsigned>(abs_value * 2);\n 2975:         *buffer++ = internal::Data::DIGITS[index];\n 2976:         *buffer++ = internal::Data::DIGITS[index + 1];\n 2977          return;\n 2978      }\n ....\n 3018  #endif\n 3019  \n 3020: // This is used to work around VC++ bugs in handling variadic macros.\n 3021  #define FMT_EXPAND(args) args\n 3022  \n ....\n 3093  FMT_VARIADIC(void, print_error, const char *, int, const char *)\n 3094  \n 3095: ``FMT_VARIADIC`` is used for compatibility with legacy C++ compilers that\n 3096  don't implement variadic templates. You don't have to use this macro if\n 3097  you don't need legacy compiler support and can use variadic templates\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/details/line_logger.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/details/log_msg.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/details/logger_impl.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/details/mpmc_bounded_q.h:\n   37  The code in its current form adds the license below:\n   38  \n   39: spdlog - an extremely fast and easy to use c++11 logging library.\n   40  Copyright (c) 2014 Gabi Melman.\n   41  \n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/details/null_mutex.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/details/os.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n    .\n  205  #elif __linux__\n  206      return  static_cast<size_t>(syscall(SYS_gettid));\n  207: #else //Default to standard C++11 (OSX and other Unix)\n  208      return static_cast<size_t>(std::hash<std::thread::id>()(std::this_thread::get_id()));\n  209  #endif\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/details/pattern_formatter_impl.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n    .\n  461      auto end = pattern.end();\n  462      std::unique_ptr<details::aggregate_formatter> user_chars;\n  463:     for (auto it = pattern.begin(); it != end; ++it)\n  464      {\n  465          if (*it == '%')\n  ...\n  468                  _formatters.push_back(std::move(user_chars));\n  469  \n  470:             if (++it != end)\n  471                  handle_flag(*it);\n  472              else\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/details/registry.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/details/spdlog_impl.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/sinks/base_sink.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/sinks/file_sinks.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/sinks/null_sink.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/sinks/ostream_sink.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/sinks/sink.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/sinks/stdout_sinks.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/sinks/syslog_sink.h:\n    1  /*************************************************************************/\n    2: /* spdlog - an extremely fast and easy to use c++11 logging library.     */\n    3  /* Copyright (c) 2014 Gabi Melman.                                       */\n    4  /*                                                                       */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/inputs/input_time_series.h:\n   43          if(fmod(s._t, c.dt) > 0.0001) return InputBase::def_value;\n   44          assert(seq->size() > s.index);\n   45:         return seq->at(s.index++);\n   46  	}\n   47  \n\n/home/alexeyche/prog/dnn/dnn_project/dnn/io/serialize.h:\n  184          if(!messages->empty()) {\n  185              // cout << name() << \" stack: \\n\\t\";\n  186:             // for(size_t i=0; i<(messages->size()-1); ++i) {\n  187              //     cout << (*messages)[i]->GetTypeName() << \", \";\n  188              // }\n  ...\n  233          }\n  234          string ret;\n  235:         for(size_t i=1; i<spl.size(); ++i) {\n  236              ret += spl[i];\n  237          }\n  ...\n  286              ASSERT_FIELDS() \\\n  287              if(mode == ProcessingOutput) { \\\n  288:                 for(size_t i=0; i<v.size(); ++i) { \\\n  289                      currentMessage()->GetReflection()->pbmethod_add(currentMessage(), field_descr, v[i]); \\\n  290                  } \\\n  291              } else { \\\n  292                  int cur = currentMessage()->GetReflection()->FieldSize(*currentMessage(), field_descr); \\\n  293:                 for(int i=0; i<cur; ++i) { \\\n  294                      type subv = currentMessage()->GetReflection()->pbmethod_get(*currentMessage(), field_descr, i); \\\n  295                      v.push_back(subv); \\\n  ...\n  318          }\n  319          if(mode == ProcessingOutput) {\n  320:             for(size_t i=0; i<v.size(); ++i) {\n  321                  currentMessage()->GetReflection()->AddDouble(currentMessage(), field_descr, v[i].real());\n  322                  currentMessage()->GetReflection()->AddDouble(currentMessage(), imag_field_descr, v[i].imag());\n  ...\n  324          } else {\n  325              int cur = currentMessage()->GetReflection()->FieldSize(*currentMessage(), field_descr);\n  326:             for(int i=0; i<cur; ++i) {\n  327                  double subv = currentMessage()->GetReflection()->GetRepeatedDouble(*currentMessage(), field_descr, i);\n  328                  double subv_imag = currentMessage()->GetReflection()->GetRepeatedDouble(*currentMessage(), imag_field_descr, i);\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/io/stream.cpp:\n   67  	}\n   68  \n   69: 	for (size_t i = 0; i < cl->size(); ++i) {\n   70  		protoReader(messages);\n   71  	}\n   ..\n   83  \n   84  	bool has_object = false;\n   85: 	for (Value::ConstMemberIterator itr = v.MemberBegin(); itr != v.MemberEnd(); ++itr) {\n   86  		if (itr->value.IsObject()) {\n   87  			jsonReader(itr->name.GetString(), itr->value, messages);\n   ..\n  119  		}\n  120  		jsonReader(iterator->name.GetString(), iterator->value, messages);\n  121: 		iterator++;\n  122  	}\n  123  	return messages;\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/learning_rules/optimal_stdp.cpp:\n   70  \n   71          s.C.get(i) += - s.C.get(i)/c.tau_c;\n   72:         ++i;\n   73      }\n   74  \n   ..\n   93      //         s.C.setInactive(C_id_it);\n   94      //     } else {\n   95:     //         ++C_id_it;\n   96      //     }\n   97      // }\n   ..\n  102      //         stat.add(\"C\", i, s.C.get(i));\n  103      //         stat.add(\"w\", i, syn.ref().weight());\n  104:     //         ++i;\n  105      //     }\n  106      //     stat.add(\"B\", s.B);        \n\n/home/alexeyche/prog/dnn/dnn_project/dnn/learning_rules/stdp.h:\n   93  \n   94                  s.x[x_id_it] += - s.x[x_id_it]/c.tau_plus;\n   95:                 ++x_id_it;\n   96              }\n   97          }\n   ..\n  103                  stat.add(\"x\", i, s.x.get(i));\n  104                  stat.add(\"w\", i, syn.ref().weight());\n  105:                 ++i;\n  106              }\n  107              stat.add(\"y\", s.y);\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/learning_rules/stdp_time.h:\n   93                  auto &syn = syns.get(syn_id).ref();\n   94                  if( (!(n.ref().fired()||syn.fired()) )||(s.x[x_id_it]<0.0)||(s.y<0.0)) {\n   95:                     ++x_id_it;\n   96                      continue;\n   97                  }\n   ..\n  112  \n  113                  //if((n.ref().id() == 101)&&(t.t>=2500)) cout << \"(id_pre: \" << syn.idPre() << \", dw: \" << dw << \", s.y: \" << s.y << \", s.x: \" << s.x[x_id_it] << \"), \";\n  114:                 ++x_id_it;\n  115              }\n  116          }\n  ...\n  122                  stat.add(\"x\", i, s.x.get(i));\n  123                  stat.add(\"w\", i, syn.ref().weight());\n  124:                 ++i;\n  125              }\n  126              stat.add(\"y\", s.y);\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/learning_rules/triple_stdp.h:\n  101  \n  102                  s.x[x_id_it] += - s.x[x_id_it]/c.tau_plus;\n  103:                 ++x_id_it;\n  104              }\n  105          }\n  ...\n  115                  stat.add(\"w\", i, syn.ref().weight());\n  116                  stat.add(\"ltd\", i, norm.ifc().ltd(syn.ref().weight()));\n  117:                 ++i;\n  118              }\n  119              stat.add(\"y\", s.y);\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/neurons/spike_neuron.cpp:\n  110  			it = rstat.erase(it);\n  111  		} else {\n  112: 			++it;\n  113  		}\n  114  	}\n  ...\n  118  		if(s.ref().getStat().on()) {\n  119  			Statistics& syn_st = s.ref().getStat();\n  120: 			for(auto it=syn_st.getStats().begin(); it != syn_st.getStats().end(); ++it) {\n  121  				rstat[s.ref().name() + \"_\" +  it->first + \"_\" + std::to_string(syn_id)] = it->second;\n  122  			}\n  123  		}\n  124: 		++syn_id;\n  125  	}\n  126  	if((lrule.isSet())&&(lrule.ref().getStat().on())) {\n  127  		Statistics &lrule_st = lrule.ref().getStat();\n  128: 		for(auto it=lrule_st.getStats().begin(); it != lrule_st.getStats().end(); ++it) {\n  129  			rstat[ lrule.ref().name() + \"_\" + it->first ] = it->second;\n  130  		}\n  ...\n  133  	if((lrule.isSet())&&(lrule.ref().getWeightNormalization().isSet())&&(lrule.ref().getWeightNormalization().ref().getStat().on())) {\n  134  		Statistics &lrule_st = lrule.ref().getWeightNormalization().ref().getStat();\n  135: 		for(auto it=lrule_st.getStats().begin(); it != lrule_st.getStats().end(); ++it) {\n  136  			rstat[ lrule.ref().getWeightNormalization().ref().name() + \"_\" + it->first ] = it->second;\n  137  		}\n  ...\n  173          } else {\n  174          	Isyn += x;\n  175:         	++syn_id_it;\n  176          }\n  177      }\n  ...\n  186     		}\n  187      } else {\n  188:         for(auto syn_id_it = syns.ibegin(); syn_id_it != syns.iend(); ++syn_id_it) {\n  189              auto &s = syns[syn_id_it];\n  190              s.ifc().calculateDynamics(t);\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/neurons/spike_neuron.h:\n   32  public:\n   33  	SpikeNeuronBase() : input_queue_lock(ATOMIC_FLAG_INIT), _fired(false) {\n   34: 		_id = global_neuron_index++;\n   35  	}\n   36  \n   ..\n  193  			syns.resize(info.num_of_synapses);\n  194  		}\n  195: 		for (size_t i = 0; i < info.num_of_synapses; ++i) {\n  196  			(*this) << \"Synapse: \" << syns[i];\n  197  		}\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/neurons/spike_sequence_neuron.h:\n   62          const double &spike_time = seq[s.index];\n   63          if((spike_time>=t.t)&&(spike_time<(t.t+t.dt))) {\n   64:             s.index++;\n   65              setFired(true);\n   66          }\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/sim/builder.cpp:\n   18          size_t xi = 0;\n   19          size_t yi = 0;\n   20:         for (size_t ni = 0; ni < layer_size; ++ni) {\n   21              InterfacedPtr<SpikeNeuronBase> n;\n   22  \n   ..\n   44                  }\n   45                  n.ref().setCoordinates(xi, yi, col_size);\n   46:                 xi++;\n   47                  if(xi % col_size == 0) {\n   48:                     yi++;\n   49                      xi = 0;\n   50                  }\n   ..\n   58      }\n   59  \n   60:     for (auto it = c.sim_conf.files.begin(); it != c.sim_conf.files.end(); ++it) {\n   61          const string &obj_name = it->first;\n   62          Document file_conf = Json::parseStringC(it->second);\n   ..\n   70  \n   71          auto slice = Factory::inst().getObjectsSlice(obj_name);\n   72:         for(auto it=slice.first; it != slice.second; ++it) {\n   73              Ptr<SerializableBase> o = Factory::inst().getObject(it);\n   74              // L_DEBUG << \"Builder, providing input for \" << o->name();\n   ..\n   79  \n   80      if (!input_stream) {\n   81:         for (auto it = c.sim_conf.conn_map.begin(); it != c.sim_conf.conn_map.end(); ++it) {\n   82              size_t l_id_pre = it->first.first;\n   83              size_t l_id_post = it->first.second;\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/sim/builder.h:\n   27  \n   28  	static void turnOnStatistics(vector<InterfacedPtr<SpikeNeuronBase>> &neurons, const vector<size_t> &ids) {\n   29: 		for(auto it=ids.cbegin(); it != ids.cend(); ++it) {\n   30  			if(*it >= neurons.size()) {\n   31  				throw dnnException() << \"Can't find neuron \" << *it << \" to listen\\n\";\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/sim/network.h:\n   30                  	Conn(n.ref(), con_i)\n   31                  );\n   32:                 ++con_i;\n   33              }\n   34          }\n   ..\n   54  		str << \"Network: \\n\";\n   55  		str << \"\\tConnMap: \\n\";\n   56: 		for(size_t i=0; i<conn_map.size(); ++i) {\n   57  			cout << \"neuron \" << i << \" cause spike in: \";\n   58  			cout << conn_map[i];\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/sim/sim.cpp:\n   50  	Time t(s.c.sim_conf.dt);\n   51  \n   52: 	for(size_t i=from; i<to; ++i) {\n   53  		s.neurons[i].ref().resetInternal();\n   54  	}\n   ..\n   63  	#endif\n   64  \n   65: 	for(; t<s.duration; ++t) {\n   66  		// L_DEBUG << \"[Layer of neurons \" << from << \":\" << to << \"] Tick at time \" << t.t;\n   67: 		for(size_t i=from; i<to; ++i) {\n   68  			// L_DEBUG << \"[Layer of neurons \" << from << \":\" << to << \"] Simulating neuron \" << i;\n   69  			s.neurons[i].ref().calculateDynamicsInternal(t);\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/util/act_vector.h:\n   67  	}\n   68      friend std::ostream& operator<<(std::ostream& str, const ActVector &self) {\n   69:         for(size_t i=0; i<self.size(); ++i) {\n   70          	cout << i << \":\";\n   71          	if(self.act_indices.find(i) == self.act_indices.end()) {\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/util/fast_delegate.h:\n    1  //						FastDelegate.h\n    2: //	Efficient delegates in C++ that generate only two lines of asm code!\n    3  //  Documentation is found at http://www.codeproject.com/cpp/FastDelegate.asp\n    4  //\n    .\n   10  //				  * Improved syntax for horrible_cast (thanks Paul Bludov).\n   11  //				  * Tested on Metrowerks MWCC and Intel ICL (IA32)\n   12: //				  * Compiled, but not run, on Comeau C++ and Intel Itanium ICL.\n   13: //	27-Jun-04 1.2 * Now works on Borland C++ Builder 5.5\n   14: //				  * Now works on /clr \"managed C++\" code on VC7, VC7.1\n   15: //				  * Comeau C++ now compiles without warnings.\n   16  //				  * Prevent the virtual inheritance case from being used on\n   17  //					  VC6 and earlier, which generate incorrect code.\n   ..\n   31  //				  * Added include guards\n   32  //				  * Added FastDelegate::empty() to test if invocation is safe (Thanks Neville Franks).\n   33: //				  * Now tested on VS 2005 Express Beta, PGI C++\n   34  // 24-Dec-04 1.4  * Added DelegateMemento, to allow collections of disparate delegates.\n   35  //                * <,>,<=,>= comparison operators to allow storage in ordered containers.\n   ..\n   76  ////////////////////////////////////////////////////////////////////////////////\n   77  \n   78: // Compiler identification. It's not easy to identify Visual C++ because\n   79  // many vendors fraudulently define Microsoft's identifiers.\n   80  #if defined(_MSC_VER) && !defined(__MWERKS__) && !defined(__VECTOR_C) && !defined(__ICL) && !defined(__BORLANDC__)\n   ..\n  144  \n  145  //		implicit_cast< >\n  146: // I believe this was originally going to be in the C++ standard but\n  147  // was left out by accident. It's even milder than static_cast.\n  148  // I use it instead of static_cast<> to emphasize that I'm not doing\n  ...\n  155  \n  156  //		horrible_cast< >\n  157: // This is truly evil. It completely subverts C++'s type system, allowing you\n  158  // to cast from any class to any other class. Technically, using a union\n  159  // to perform the cast is undefined behaviour (even in C). But we can see if\n  ...\n  261  #endif\n  262  	// ...but for Codeplay, an empty class *always* gives 4 byte pointers.\n  263: 	// If compiled with the /clr option (\"managed C++\"), the JIT compiler thinks\n  264  	// it needs to load GenericClass before it can call any of its functions,\n  265  	// (compiles OK but crashes at runtime!), so we need to declare an\n  ...\n  365  // assumptions about the calling convention that is used.\n  366  \n  367: // In VC++ and ICL, a virtual_inheritance member pointer\n  368  // is internally defined as:\n  369  struct MicrosoftVirtualMFP {\n  ...\n  420  #if (_MSC_VER <1300)\n  421  \n  422: // Nasty hack for Microsoft Visual C++ 6.0\n  423  // unknown_inheritance classes go here\n  424  // There is a compiler bug in MSVC6 which generates incorrect code in this case!!\n  ...\n  475  		union {\n  476  			XFuncType func;\n  477: 			// In VC++ and ICL, an unknown_inheritance member pointer\n  478  			// is internally defined as:\n  479  			struct {\n  ...\n  554  //  * For Metrowerks, this can be 0. (first virtual function in a\n  555  //       single_inheritance class).\n  556: // Note that the Sun C++ and MSVC documentation explicitly state that they\n  557  // support static_cast between void * and function pointers.\n  558  \n  ...\n  751  // possible to store the function pointer in the this pointer, using another\n  752  // horrible_cast. Invocation isn't any faster, but it saves 4 bytes, and\n  753: // speeds up comparison and assignment. If C++ provided direct language support\n  754  // for delegates, they would produce asm code that was almost identical to this.\n  755: // Note that the Sun C++ and MSVC documentation explicitly state that they\n  756  // support static_cast between void * and function pointers.\n  757  \n  ...\n  781  		typedef int ERROR_CantUseEvilMethod[sizeof(GenericClass *)==sizeof(function_to_bind) ? 1 : -1];\n  782  		m_pthis = horrible_cast<GenericClass *>(function_to_bind);\n  783: 		// MSVC, SunC++ and DMC accept the following (non-standard) code:\n  784  //		m_pthis = static_cast<GenericClass *>(static_cast<void *>(function_to_bind));\n  785  		// BCC32, Comeau and DMC accept this method. MSVC7.1 needs __int64 instead of long\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/util/func_param_parser.cpp:\n   35                  throw dnnException() << \"Failed to parse: \" << eq_spl[0] << \"\\n\";\n   36              }\n   37:             cb_it++;\n   38          } else\n   39          if(eq_spl.size() == 2) {\n   ..\n   45                      break;\n   46                  }\n   47:                 ++c_param_it;\n   48              }\n   49              if(c_param_it == callbacks.end()) {\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/util/gammatone_fb.h:\n   62          sincf = sin ( tpt * cf );\n   63          qcos = 1; qsin = 0;   /* t=0 & q = exp(-i*tpt*t*cf)*/\n   64:         for ( t=0; t<nsamples; t++ )\n   65          {\n   66             /* Filter part 1 & shift down to d.c. */\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/util/json.h:\n  137  		vector<size_t> ret;\n  138  		const Value &f_v = getArray(v, name);\n  139: 		for (SizeType i = 0; i < f_v.Size(); i++) {\n  140  			if (!f_v[i].IsUint()) {\n  141  				throw dnnException()<< \"Element \" << i << \" of \" << name << \" is not an uint type\\n\";\n  ...\n  189  				if ( (offset - (int)spl[line_num].size()) < 0 ) { cout << \" == somewhere in that structure an error\\n\"; break; }\n  190  				offset -= spl[line_num].size();\n  191: 				line_num++;\n  192  			}\n  193  			throw dnnException() << \"Parse JSON error:\\n\"\n  ...\n  198  \n  199  	static void aggregateSubst(const Value &parsed, vector<string> &stack, map<string, Value> &values) {\n  200: 		for (Value::ConstMemberIterator itr = parsed.MemberBegin(); itr != parsed.MemberEnd(); ++itr) {\n  201  			if (itr->value.IsObject()) {\n  202  				stack.push_back(itr->name.GetString());\n  ...\n  224  	}\n  225  	static void applySubst(Value &v, const map<string, Value> &values) {\n  226: 		for (Value::MemberIterator itr = v.MemberBegin(); itr != v.MemberEnd(); ++itr) {\n  227  			if (itr->value.IsObject()) {\n  228  				applySubst(itr->value, values);\n  ...\n  249  		Value cv;\n  250  		cv.CopyFrom(v, d.GetAllocator());\n  251: 		for (Value::MemberIterator itr = cv.MemberBegin(); itr != cv.MemberEnd(); ++itr) {\n  252  	        const google::protobuf::Descriptor* descriptor = m->GetDescriptor();\n  253  	        const google::protobuf::FieldDescriptor* field_descr = descriptor->FindFieldByName(itr->name.GetString());\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/util/matrix.h:\n   63      DoubleMatrix(const vector<double> &v) {\n   64      	allocate(v.size(), 1);\n   65:     	for(size_t i=0; i<v.size(); ++i) {\n   66      		setElement(i, 0, v[i]);\n   67      	}\n   ..\n   99  	}\n  100      void fill(double val) {\n  101: 	    for(size_t i=0; i<nrow_v; i++) {\n  102:     	    for(size_t j=0; j<ncol_v; j++) {\n  103          	    setElement(i, j, val);\n  104          	}\n  ...\n  106  	}\n  107      void norm() {\n  108:         for(size_t i=0; i<nrow(); ++i) {\n  109              double acc = 0.0;\n  110:             for(size_t j=0; j<ncol(); ++j) {\n  111                  acc += getElement(i, j) * getElement(i, j);\n  112              }\n  113              double n = sqrt(acc);\n  114:             for(size_t j=0; j<ncol(); ++j) {\n  115                  setElement(i, j, getElement(i, j)/n);\n  116              }\n  ...\n  132      void textRepr(ostream &o) {\n  133          if(unique_labels.size()>0) {\n  134:             for(size_t li=0; li<col_labels_ids.size(); ++li) {\n  135                  o << \"\\\"\" << \"col.\" << li << \".lab.\" << unique_labels[ col_labels_ids[li] ] << \"\\\"\";\n  136                  if(li<col_labels_ids.size()-1) o << \" \";\n  ...\n  138              o << \"\\n\";\n  139          }\n  140:         for(size_t i=0; i<nrow_v; ++i) {\n  141              if(unique_labels.size()>0) o << \"\\\"\" << \"row.\" << i << \".lab.\" << unique_labels[ row_labels_ids[i] ] << \"\\\"\" << \" \";\n  142:             for(size_t j=0; j<ncol_v; ++j) {\n  143                  o << getElement(i, j);\n  144                  if(j<ncol_v-1) o << \" \";\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/util/option_parser.h:\n   36  public:\n   37  	OptionParser(int argc, char **argv) {\n   38: 		for (size_t i = 1; i < argc; ++i) {\n   39  			opts.push_back(argv[i]);\n   40  		}\n   ..\n   55  						throw dnnException()<< \"Can't find value for option \" << long_opt << \"\\n\";\n   56  					}\n   57: 					src = cast<T>(*(++it));\n   58  					it = opts.erase(it - 1, it + 1);\n   59  				}\n   60  				found = true;\n   61  			} else {\n   62: 				++it;\n   63  			}\n   64  		}\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/util/pretty_print.h:\n    4  //          http://www.boost.org/LICENSE_1_0.txt)\n    5  //\n    6: // A pretty printing library for C++\n    7  //\n    8  // Usage:\n    .\n  124                          stream << *it;\n  125  \n  126:                     if (++it == the_end) break;\n  127  \n  128                      if (delimiters_type::values.delimiter != NULL)\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/util/spikes_list.cpp:\n   15      size_t max_size = std::numeric_limits<size_t>::min();\n   16      size_t max_id = 0;\n   17:     for(size_t di=0; di<seq.size(); ++di) {\n   18          double t=0;\n   19          for(const auto &spike_time: seq[di].values) {\n   ..\n   36      // cout << \"max_size: \" << max_size << \", max_spike_time: \" << max_spike_time << \" \" << max_id << \"\\n\";\n   37  \n   38:     for(size_t di=0; di<out->data.size(); ++di) {\n   39          double last_t = dt*out->data[di].values.size();\n   40          // cout << \"dim: \" << di << \", last_t: \" << last_t << \", size: \" <<  out->data[di].values.size() << \"\\n\";\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/util/spikes_list.h:\n   60  		}\n   61  \n   62: 		for(size_t i=0; i<info.size; ++i) {\n   63  			(*this) << seq[i];\n   64  		}\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/util/statistics.h:\n   18  \n   19  	void add(const double &s) {\n   20: 		if ( ((low_lim > 0) && (__counter < low_lim)) || ((high_lim > 0) && (__counter >= high_lim)) ) { __counter++; return; }\n   21  		values.push_back(s);\n   22: 		__counter++;\n   23  	}\n   24  \n   ..\n   82  	StatisticsInfo getInfo() {\n   83  		StatisticsInfo info;\n   84: 		for (auto it = stats.begin(); it != stats.end(); ++it) {\n   85  			info.stat_names.push_back(it->first);\n   86  		}\n   ..\n   97  \n   98  		begin() << \"info: \" << info << \", \";\n   99: 		for (auto it = info.stat_names.begin(); it != info.stat_names.end(); ++it) {\n  100  			(*this) << \"stat: \" << stats[*it] << \", \";\n  101  		}\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/util/time_series.cpp:\n   36      vector<Ptr<TimeSeries>> ts_chopped;\n   37      assert(info.labels_timeline.size() == info.labels_ids.size());\n   38:     for(size_t li=0; li<info.labels_timeline.size(); ++li) {\n   39          const size_t &end_of_label = info.labels_timeline[li];\n   40          const size_t &label_id = info.labels_ids[li];\n   ..\n   42  \n   43          Ptr<TimeSeries> labeled_ts(Factory::inst().createObject<TimeSeries>());\n   44:         for(; elem_id < end_of_label; ++elem_id) {\n   45:             for(size_t di=0; di<data.size(); ++di) {\n   46                  labeled_ts->addValue(di, data[di].values[elem_id]);\n   47              }\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/util/time_series.h:\n   77  	void padRightWithZeros(size_t padSize) {\n   78  		for(auto &v: data) {\n   79: 			for(size_t zi=0; zi<padSize; ++zi) {\n   80  				v.values.push_back(ELEM(0.0));\n   81  			}\n   ..\n   85  	void cutFromRight(size_t cutSize) {\n   86  		for(auto &v: data) {\n   87: 			for(size_t zi=0; zi<cutSize; ++zi) {\n   88  				v.values.pop_back();\n   89  			}\n   ..\n   97  \n   98  	void norm() {\n   99: 		for(size_t di=0; di < data.size(); ++di) {\n  100  			ELEM acc(0.0);\n  101  			for(const auto &v: data[di].values) {\n  ...\n  112  		assertAnotherTs(anotherTs);\n  113  		double acc = 1.0;\n  114: 		for(size_t di=0; di < data.size(); ++di) {\n  115  			acc *= std::inner_product(data[di].values.begin(), data[di].values.end(), anotherTs.data[di].values.begin(), 0.0);\n  116  		}\n  ...\n  121  		assertAnotherTs(anotherTs);\n  122  		double acc = 0.0;\n  123: 		for(size_t di=0; di < data.size(); ++di) {\n  124  			acc += std::inner_product(data[di].values.begin(), data[di].values.end(), anotherTs.data[di].values.begin(), 0.0)/data[di].values.size();\n  125  		}\n  ...\n  131  			throw dnnException() << \"Can't multiply time series with different dimensions or length\\n\";\n  132  		}\n  133: 		for(size_t di=0; di < data.size(); ++di) {\n  134: 			for(size_t vi=0; vi < data[di].values.size(); ++vi) {\n  135  				size_t another_ts_di = di;\n  136  				if(anotherTs.dim() == 1) {\n  ...\n  156  	vector<double> getColumnVector(size_t xi) {\n  157  		vector<double> col(dim());\n  158: 		for(size_t di=0; di < dim(); ++di) {\n  159  			assert(xi<data[di].values.size());\n  160  			col[di] = data[di].values[xi];\n  ...\n  254  			data.resize(dim_info.size);\n  255  		}\n  256: 		for(size_t i=0; i<dim_info.size; ++i) {\n  257  			(*this) << data[i];\n  258  		}\n  ...\n  264  	   assert(els.size() > 0);\n  265  \n  266: 	   for(size_t i=0; i<els.size(); i++) {\n  267  	       trim(els[i]);\n  268  	       if(!els[i].empty()) {\n  ...\n  301  			data.resize(dim_info.size);\n  302  		}\n  303: 		for(size_t i=0; i<dim_info.size; ++i) {\n  304  			(*this) << data[i];\n  305  		}\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/util/util.cpp:\n  165      vector<string> content = split(right_side.front(), ',');\n  166      vector<double> out;\n  167:     for(auto it=content.begin(); it != content.end(); ++it) {\n  168          out.push_back(stof(*it));\n  169      }\n  ...\n  174  vector<IndexSlice> dispatchOnThreads(size_t elements_size, size_t jobs) {\n  175      vector<IndexSlice> out;\n  176:     for(size_t ji=0; ji < jobs; ji++) {\n  177          int el_per_thread;\n  178          if(fabs(fmod(elements_size, jobs)) < 0.000001) {\n  ...\n  237      v |= v >> 8;\n  238      v |= v >> 16;\n  239:     v++;\n  240      return v;\n  241  }\n  ...\n  268      }\n  269  \n  270:     for (j = 0; j < nptrs; j++)\n  271         printf(\"%s\\n\", strings[j]);\n  272  \n\n/home/alexeyche/prog/dnn/dnn_project/dnn/util/random/pcg_extras.hpp:\n    1  /*\n    2:  * PCG Random Number Generation for C++\n    3   *\n    4   * Copyright 2014 Melissa O'Neill <oneill@pcg-random.org>\n    .\n   68   * for the job.\n   69   *\n   70:  * On 32-bit platforms (or with other compilers), we fall back to a C++\n   71   * class that provides 128-bit unsigned integers instead.  It may seem\n   72   * like we're reinventing the wheel here, because libraries already exist\n   ..\n  112  \n  113  /*\n  114:  * C++ requires us to be able to serialize RNG state by printing or reading\n  115   * it from a stream.  Because we use 128-bit ints, we also need to be able\n  116   * ot print them, so here is code to do so.\n  ...\n  354  \n  355  /*\n  356:  * The C++ SeedSeq concept (modelled by seed_seq) can fill an array of\n  357   * 32-bit integers with seed data, but sometimes we want to produce\n  358   * larger or smaller integers.\n  ...\n  397  \n  398      while (dest_first != dest_last) {\n  399:         if ((count++ % SCALE) == 0)\n  400:             value = *src_first++;       // Get more bits\n  401          else\n  402              value >>= DEST_BITS;        // Move down bits\n  403  \n  404:         *dest_first++ = dest_t(value);  // Truncates, ignores high bits.\n  405      }\n  406      return src_first;\n  ...\n  426          unsigned int shift = 0;\n  427  \n  428:         for (size_t i = 0; i < SCALE; ++i) {\n  429:             value |= dest_t(*src_first++) << shift;\n  430              shift += SRC_BITS;\n  431          }\n  432  \n  433:         *dest_first++ = value;\n  434      }\n  435      return src_first;\n  ...\n  549   * Technically, it does not meet the requirements of a SeedSequence because\n  550   * it lacks some of the rarely-used member functions (some of which would\n  551:  * be impossible to provide).  However the C++ standard is quite specific\n  552   * that actual engines only called the generate method, so it ought not to be\n  553   * a problem in practice.\n  ...\n  572      void generate(Iter start, Iter finish)\n  573      {\n  574:         for (auto i = start; i != finish; ++i)\n  575              *i = result_type(rng_());\n  576      }\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/util/random/pcg_random.hpp:\n    1  /*\n    2:  * PCG Random Number Generation for C++\n    3   *\n    4   * Copyright 2014 Melissa O'Neill <oneill@pcg-random.org>\n    .\n   38   *        LCG, settable-stream LCG, unique-stream LCG)\n   39   *      - and the extended generation schemes allowing arbitrary periods\n   40:  *      - with all features of C++11 random number generation (and more),\n   41   *        some of which are somewhat painful, including\n   42   *            - initializing with a SeedSequence which writes 32-bit values\n   ..\n   50   *\n   51   * The code employes a fairly heavy level of abstraction, and has to deal\n   52:  * with various C++ minutia.  If you're looking to learn about how the PCG\n   53   * scheme works, you're probably best of starting with one of the other\n   54   * codebases (see www.pcg-random.org).  But if you're curious about the\n   ..\n  750   * All of the classes have code that is written to allow it to be applied\n  751   * at *arbitrary* bit sizes, although in practice they'll only be used at\n  752:  * standard sizes supported by C++.\n  753   */\n  754  \n  ...\n 1327           const result_type* data)\n 1328  {\n 1329:     for (size_t i = 0; i < table_size; ++i)\n 1330          data_[i] = data[i];\n 1331  }\n ....\n 1346      //        was generating the same values again\n 1347      result_type xdiff = baseclass::operator()() - baseclass::operator()();\n 1348:     for (size_t i = 0; i < table_size; ++i) {\n 1349          data_[i] = baseclass::operator()() ^ xdiff;\n 1350      }\n ....\n 1436  {\n 1437      bool carry = false;\n 1438:     for (size_t i = 0; i < table_size; ++i) {\n 1439          if (carry) {\n 1440              carry = insideout::external_step(data_[i],i+1);\n ....\n 1459  \n 1460      base_state_t carry = 0;\n 1461:     for (size_t i = 0; i < table_size; ++i) {\n 1462          base_state_t total_delta = carry + delta;\n 1463          ext_state_t  trunc_delta = ext_state_t(total_delta);\n ....\n 1492              next_advance_distance = (-next_advance_distance) & tick_mask;\n 1493          if (next_advance_distance < (distance & tick_mask)) {\n 1494:             ++ticks;\n 1495          }\n 1496          if (ticks)\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/util/random/pcg_uint128.hpp:\n    1  /*\n    2:  * PCG Random Number Generation for C++\n    3   *\n    4   * Copyright 2014 Melissa O'Neill <oneill@pcg-random.org>\n    .\n   23  \n   24  /*\n   25:  * This code provides a a C++ class that can provide 128-bit (or higher)\n   26   * integers.  To produce 2K-bit integers, it uses two K-bit integers,\n   27   * placed in a union that allowes the code to also see them as four K/2 bit\n   ..\n   95   */\n   96  \n   97: #ifdef __GNUC__         // Any GNU-compatible compiler supporting C++11 has\n   98                          // some useful intrinsics we can use.\n   99  \n  ...\n  436          --i;\n  437  #else\n  438:     for (uint8_t i = 0; i < 4; ++i) {\n  439  #endif\n  440          if (v.wa[i] == 0)\n  ...\n  449  {\n  450  #if PCG_LITTLE_ENDIAN\n  451:     for (uint8_t i = 0; i < 4; ++i) {\n  452  #else\n  453      for (uint8_t i = 4; i !=0; /* dec in loop */) {\n  ...\n  689          UInt carryover = 0;\n  690  #if PCG_LITTLE_ENDIAN\n  691:         for (uint8_t out = shiftdiv, in = 0; out < 4; ++out, ++in) {\n  692  #else\n  693          for (uint8_t out = 4-shiftdiv, in = 4; out != 0; /* dec in loop */) {\n  ...\n  699      } else {\n  700  #if PCG_LITTLE_ENDIAN\n  701:         for (uint8_t out = shiftdiv, in = 0; out < 4; ++out, ++in) {\n  702  #else\n  703          for (uint8_t out = 4-shiftdiv, in = 4; out != 0; /* dec in loop */) {\n  ...\n  727              --out, --in;\n  728  #else\n  729:         for (uint8_t out = shiftdiv, in = 0; out < 4; ++out, ++in) {\n  730  #endif\n  731              r.wa[out] = (v.wa[in] >> shiftmod) | carryover;\n  ...\n  737              --out, --in;\n  738  #else\n  739:         for (uint8_t out = shiftdiv, in = 0; out < 4; ++out, ++in) {\n  740  #endif\n  741              r.wa[out] = v.wa[in];\n\n/home/alexeyche/prog/dnn/dnn_project/mpl/mpl.cpp:\n   40      }\n   41      filter.allocate(c.filters_num, c.filter_size);\n   42:     for(size_t i=0; i<c.filters_num; ++i) {\n   43          double acc = 0.0;\n   44:         for(size_t j=0; j<c.filter_size; ++j) {\n   45              filter(i, j) = getNorm();\n   46              acc += filter(i, j) * filter(i, j);\n   47          }\n   48          double n = sqrt(acc);\n   49:         for(size_t j=0; j<c.filter_size; ++j) {\n   50              filter(i, j) = filter(i, j)/n;\n   51          }\n   ..\n   73      for(auto &v: restored) v = 0.0;\n   74      for(auto &m: matches) {\n   75:         for(size_t i=0; i<filter.ncol(); ++i) {\n   76              restored[m.t + i - from] += m.s * filter(m.fi, i) + distribution(generator);\n   77          }\n   ..\n   92          r.dfilter.fill(0.0);\n   93      }\n   94:     for(size_t i=from; i<to; ++i) {\n   95          if(i >= ts.data[dim].values.size()) {\n   96              throw dnnException() << \"Trying to get value out of input data: \" << dim << \":\" << i << \"\\n\";\n   ..\n   99      }\n  100  \n  101:     for(size_t ti=0; ti<(r.residual.size()-self.filter.ncol()); ++ti) {\n  102          size_t ti_f = ti+self.filter.ncol();\n  103  \n  104          double x_denom = 0.0;\n  105:         for(size_t xi=ti; xi<ti_f; ++xi) {\n  106              x_denom += r.residual[xi]*r.residual[xi];\n  107          }\n  108          x_denom = sqrt(x_denom);\n  109:         for(size_t i=0; i<self.c.learn_iterations; ++i) {\n  110              double max_s = -100;\n  111              size_t max_fi = 0;\n  112  \n  113:             for(size_t fi=0; fi<self.filter.nrow(); ++fi) {\n  114                  double s_f=0;\n  115:                 for(size_t xi=ti; xi<ti_f; ++xi) {\n  116                      s_f += (r.residual[xi]/x_denom) * self.filter(fi, xi-ti);\n  117                  }\n  ...\n  128                  FilterMatch m(max_fi, max_s, ti+from);\n  129  \n  130:                 for(size_t xi=ti; xi<ti_f; ++xi) {\n  131                      r.residual[xi] -= x_denom * m.s * self.filter(m.fi, xi-ti);\n  132                  }\n  ...\n  145              double x_denom = 0.0;\n  146              double y_denom = 0.0;\n  147:             for(size_t i=0; i<self.filter.ncol(); ++i) {\n  148                  x_denom += ts.data[dim].values[m.t + i] * ts.data[dim].values[m.t + i];\n  149                  y_denom += restored[m.t + i - from] * restored[m.t + i - from];\n  ...\n  151              x_denom = sqrt(x_denom);\n  152              y_denom = sqrt(y_denom);\n  153:             for(size_t i=0; i<self.filter.ncol(); ++i) {\n  154                  double delta = ts.data[dim].values[m.t + i]/x_denom - restored[m.t + i - from]/y_denom;\n  155                  // double delta = ts.data[dim].values[m.t + i] - restored[m.t + i - from];\n  ...\n  199          if(c.learn) {\n  200              for(auto &ret : rets) {\n  201:                 for(size_t i=0; i<filter.nrow(); ++i) {\n  202                      double acc = 0.0;\n  203:                     for(size_t j=0; j<filter.ncol(); ++j) {\n  204                          filter(i, j) += c.learning_rate * ret.dfilter(i, j);\n  205                          acc += filter(i, j) * filter(i, j);\n  206                      }\n  207                      double n = sqrt(acc);\n  208:                     for(size_t j=0; j<filter.ncol(); ++j) {\n  209                          filter(i, j) = filter(i, j)/n;\n  210                      }\n\n/home/alexeyche/prog/dnn/dnn_project/shapelets/common.h:\n   16      for(const auto &v: oh) {\n   17          o << v.second;\n   18:         ++i;\n   19          if(i < oh.size()) o << \", \";\n   20      }\n\n/home/alexeyche/prog/dnn/dnn_project/shapelets/dataset.cpp:\n   18                  auto p = class_ids.find(lab);\n   19                  if(p == class_ids.end()) {\n   20:                     class_ids.insert(std::make_pair(lab, class_id++));\n   21                  }\n   22              }\n\n/home/alexeyche/prog/dnn/dnn_project/shapelets/dataset.h:\n   62              hist.insert(std::make_pair(v, 1));\n   63          } else {\n   64:             ++(p->second);\n   65          }\n   66      }\n\n/home/alexeyche/prog/dnn/dnn_project/shapelets/dist.cpp:\n   36  \n   37      double total_dist = 0.0;\n   38:     for(size_t di=0; di<left.dim(); ++di) {\n   39          double m_left = mean(left, stats, di);\n   40          double m_right = mean(right, stats, di);\n\n/home/alexeyche/prog/dnn/dnn_project/shapelets/orderline.cpp:\n   12          _all_min = false;\n   13      }\n   14:     for(auto ptr = projs.begin(); ptr != projs.end(); ++ptr) {\n   15          if(newp.dist <= ptr->dist) {\n   16              projs.insert(ptr, newp);\n   ..\n   26      }\n   27      SplitStat split_stat;\n   28:     for(size_t split_pos = 0; split_pos < projs.size(); ++split_pos) {\n   29          unordered_map<size_t, size_t> left_classes_hist(d.C());\n   30          unordered_map<size_t, size_t> right_classes_hist(d.C());\n   ..\n   34  \n   35          double sumDistLeft = 0.0, sumDistRight = 0.0;\n   36:         for(size_t pi=0; pi<N_left; ++pi) {\n   37              const Projection &left_prj = projs[pi];\n   38  \n   ..\n   40              sumDistLeft += left_prj.dist;\n   41          }\n   42:         for(size_t pi=N_left; pi<projs.size(); ++pi) {\n   43              const Projection &right_prj = projs[pi];\n   44  \n   ..\n   70      split_stat.split_dist = splitDist(split_stat.split_position);\n   71  \n   72:     for(size_t ci=0; ci < d.C(); ++ci) {\n   73          // L_INFO << (double) split_stat.left_classes_hist[ci] / (double) split_stat.N_left << \" < \" << (double) split_stat.right_classes_hist[ci] / (double) split_stat.N_right;\n   74          if( ( (double) split_stat.left_classes_hist[ci] / (double) split_stat.N_left ) >\n   ..\n  129      const unordered_map<size_t, size_t>& class_hist = d.class_hist();\n  130  \n  131:     for(size_t ci=0; ci<d.C(); ++ci) {\n  132          size_t remained = class_hist.at(ci) - split_stat.left_classes_hist[ci] - split_stat.right_classes_hist[ci];\n  133          if(split_stat.leftMajorHas(ci)) {\n  ...\n  173  \n  174      double max_gain = 0.0;\n  175:     for(size_t pi = 0; pi < projs.size()-1; ++pi) {\n  176          double tau = (projs[pi].dist + projs[pi+1].dist)/2.0;\n  177          // L_INFO << \"tau: \" << tau;\n  ...\n  193                  // L_INFO << \"Moving \" << p.class_id << \" to the left major\";\n  194  \n  195:                 new_left_hist[p.class_id]++;\n  196                  new_right_hist[p.class_id]--;\n  197              } else\n  198              if(split_stat.rightMajorHas(p.class_id) && new_left_hist[p.class_id] > 0) {\n  199                  // L_INFO << \"Moving \" << p.class_id << \" to the right major\";\n  200:                 new_right_hist[p.class_id]++;\n  201                  new_left_hist[p.class_id]--;\n  202              }\n\n/home/alexeyche/prog/dnn/dnn_project/shapelets/shapelets_algo.cpp:\n   75      Split best_split;\n   76  \n   77:     for(size_t k=0; k<dataset.N(); ++k) {\n   78          Ptr<TimeSeries> currentTs = dataset(k);\n   79          L_DEBUG << \"Perfoming main loop on dataset \" << k;\n   ..\n   85              deque<Split> poorCache;\n   86  \n   87:             for(size_t pos = 0; pos < currentTs->length() - len + 1 ; pos++ ) {\n   88                  Subsequence candidate(currentTs, k, pos, len);\n   89  \n   ..\n  113                  if(pruned) {\n  114                      L_INFO << \"Pruning ...\";\n  115:                     algo_stat.numberOfPruned++;\n  116                      // continue;\n  117                  }\n  118  \n  119:                 for(size_t l=0; l<dataset.N(); ++l) {\n  120                      double best_dist = std::numeric_limits<double>::max();\n  121:                     for(size_t comp_pos=0; comp_pos < (dataset(l)->length()-candidate.length()); ++comp_pos) {\n  122                          Subsequence comp_sub(dataset(l), l, comp_pos, candidate.length());\n  123  \n\n/home/alexeyche/prog/dnn/dnn_project/shapelets/stats.cpp:\n   14          vector<vector<double>> cumSums;\n   15          vector<vector<double>> cumSumsSquared;\n   16:         for(size_t di=0; di<ts->dim(); ++di) {\n   17              auto vec = ts->getVector(di);\n   18  \n   ..\n   23              v_sq[0] = 0.0;\n   24  \n   25:             for(size_t k=0; k<vec.size(); ++k) {\n   26                  v[k+1] = v[k] + vec[k];\n   27                  v_sq[k+1] = v_sq[k] + vec[k]*vec[k];\n   ..\n   55      clean();\n   56      L_DEBUG << \"Calculating dependent time series related stastics\";\n   57:     for(size_t ni=0; ni<ds.N(); ++ni) {\n   58          if(currentTs->dim() != ds(ni)->dim()) {\n   59              throw dnnException() << \"Found non homogeneous dataset while calculating stat\";\n   ..\n   61  \n   62          vector<Ptr<DoubleMatrix>> tsStat;\n   63:         for(size_t di=0; di<currentTs->dim(); ++di) {\n   64              tsStat.push_back(new DoubleMatrix());\n   65          }\n   ..\n   95      size_t m = ts_right.length();\n   96  \n   97:     for(size_t di=0; di<dst.size(); ++di) {\n   98          const vector<double> &x = ts_left.getVector(di);\n   99          const vector<double> &y = ts_right.getVector(di);\n  ...\n  101          d.allocate(n+1, m+1);\n  102  \n  103:         for(size_t col = 0; col < ts_left.length(); ++col) {\n  104:             for(size_t row = 0; row < ts_right.length(); ++row) {\n  105                  if( (col == 0) || (row == 0) ) {\n  106                      d(col, row) = 0.0;\n  ...\n  116      // size_t L = (n > m) ? n : m;\n  117  \n  118:     // for(size_t di=0; di<dst.size(); ++di) {\n  119      //     const vector<double> &x = ts_left.getVector(di);\n  120      //     const vector<double> &y = ts_right.getVector(di);\n  ...\n  123  \n  124      //     int i , j , k;\n  125:     //     for( k = 0 ; k < L ; k++ )\n  126      //     {\n  127      //         // L_DEBUG << \"k: \" << k;\n  ...\n  129      //         {\n  130      //             d(k,0) = 0.0; //x[k]*y[0];\n  131:     //             for( i = k+1 , j = 0 ; i < n && j < m ; i++, j++ ) {\n  132      //                 // L_DEBUG << \"i: \" << i;\n  133      //                 d(i+1, j) = d(i-1, j-1)+x[i]*y[j];\n  ...\n  138      //         {\n  139      //             d(0, k) = 0.0; //x[0]*y[k];\n  140:     //             for( i = 1 , j = k+0 ; i < n && j < m ; i++, j++ ) {\n  141      //                d(i, j) = d(i-1, j-1)+x[i]*y[j];\n  142      //                // L_DEBUG << \"i: \" << i;\n\n/home/alexeyche/prog/dnn/dnn_project/shapelets/subsequence.cpp:\n   13  \n   14      Ptr<TimeSeries> cut(Factory::inst().createObject<TimeSeries>());\n   15:     for(size_t di=0; di<_referent->dim(); ++di) {\n   16          const vector<double> v = _referent->getVector(di);\n   17:         for(size_t i=_from; i<(_from+_length); ++i) {\n   18              cut->addValue(di, v[i]);\n   19          }\n\n/home/alexeyche/prog/dnn/dnn_project/spikework/fft.cpp:\n   38      kiss_fft_cpx *data_out = new kiss_fft_cpx[out_ts_size];\n   39  \n   40:     for(size_t di=0; di<src.dim(); ++di) {\n   41          L_DEBUG << \"FFTWorker, fft processing \" << di << \" dimension\";\n   42          const vector<double> &v = src.getVector(di);\n   43:         for(size_t val_i=0; val_i<ts_size; ++val_i) {\n   44              data_in[val_i] = v[val_i];\n   45          }\n   46          kiss_fftr(c, data_in, data_out);\n   47  \n   48:         for(size_t val_i=0; val_i<out_ts_size; ++val_i) {\n   49              dst.addValue(\n   50                  di,\n   ..\n   74      kiss_fft_scalar *data_out = new kiss_fft_scalar[out_size];\n   75  \n   76:     for(size_t di=0; di<src.dim(); ++di) {\n   77          L_DEBUG << \"FFTWorker, fft inverse processing \" << di << \" dimension\";\n   78          const vector<complex<double>> &v = src.getVector(di);\n   79:         for(size_t val_i=0; val_i<ts_size; ++val_i) {\n   80              data_in[val_i].r = v[val_i].real();\n   81              data_in[val_i].i = v[val_i].imag();\n   ..\n   83          kiss_fftri(c, data_in, data_out);\n   84  \n   85:         for(size_t val_i=0; val_i<out_size; ++val_i) {\n   86              dst.addValue(di, data_out[val_i]/out_size);\n   87          }\n\n/home/alexeyche/prog/dnn/dnn_project/spikework/gram.cpp:\n   42      Ptr<DoubleMatrix> gram_matrix(Factory::inst().createObject<DoubleMatrix>());\n   43      gram_matrix->allocate(ts_chopped.size(), ts_chopped.size());\n   44:     for(size_t i=0; i<ts_chopped.size(); ++i) {\n   45          gram_matrix->setRowLabel(i, ts_chopped[i]->getLabel());\n   46:         for(size_t j=0; j<ts_chopped.size(); ++j) {\n   47              gram_matrix->setColLabel(j, ts_chopped[j]->getLabel());\n   48              if(mode == MUL) {\n\n/home/alexeyche/prog/dnn/dnn_project/spikework/kernel.cpp:\n   24      }\n   25      Ptr<TimeSeries> out(Factory::inst().createObject<TimeSeries>());\n   26:     for(size_t di=0; di<dim; ++di) {\n   27          double max_t = length * dt;\n   28          for(double s=0; s<max_t; s+=dt) {\n   ..\n  134          L_DEBUG << \"KernelWorker, Calculating kernel values in \" << jobs << \" jobs\";\n  135  \n  136:         for(size_t i=0; i<ts_chopped.size(); ++i) {\n  137:             for(size_t j=i; j<ts_chopped.size(); ++j) {\n  138                  corpus.push_back(kern_corpus(i, j, ts_chopped[i], ts_chopped[j]));\n  139              }\n  ...\n  145                  [&](size_t from, size_t to) {\n  146                      L_DEBUG << \"KernelWorker, Working on slice \" << from << \":\" << to;\n  147:                     for(size_t iter=from; iter<to; ++iter) {\n  148                          const auto &tup = corpus[iter];\n  149                          m(std::get<0>(tup), std::get<1>(tup)) = k.process(std::get<2>(tup), std::get<3>(tup));\n  ...\n  156              w.join();\n  157          }\n  158:         for(size_t i=0; i<m.nrow(); ++i) {\n  159              m.setRowLabel(i, ts_chopped[i]->getLabel());\n  160:             for(size_t j=0; j<i; ++j) {\n  161                  m(i, j) = m(j, i);\n  162              }\n  163:             for(size_t j=i; j<ts_chopped.size(); ++j) {\n  164                  if(i == 0) {\n  165                      m.setColLabel(j, ts_chopped[j]->getLabel());\n\n/home/alexeyche/prog/dnn/dnn_project/spikework/kernel.h:\n   29          assert((x->dim() == y->dim()) && (x->length() == y->length()));\n   30          double integral = 0.0;\n   31:         for(size_t i=0; i<x->length(); ++i) {\n   32              vector<double> xc = x->getColumnVector(i);\n   33              vector<double> yc = y->getColumnVector(i);\n\n/home/alexeyche/prog/dnn/dnn_project/spikework/kernel_old.cpp:\n   17      }\n   18      Ptr<TimeSeries> out(Factory::inst().createObject<TimeSeries>());\n   19:     for(size_t di=0; di<dim; ++di) {\n   20          double max_t = length * dt;\n   21          for(double s=0; s<max_t; s+=dt) {\n\n/home/alexeyche/prog/dnn/dnn_project/spikework/kernels/anova_dot.cpp:\n   17      assert(x.size() == y.size());\n   18      double acc = 0.0;\n   19:     for(size_t i=0; i<x.size(); ++i) {\n   20          acc += fastexp(-o.sigma*(x[i] - y[i])*(x[i] - y[i]));\n   21      }\n\n/home/alexeyche/prog/dnn/dnn_project/spikework/kernels/dot.cpp:\n   15      double acc = 0.0;\n   16      double x_norm = 0.0, y_norm = 0.0;\n   17:     for(size_t i=0; i<x.size(); ++i) {\n   18          acc += x[i]*y[i];\n   19          x_norm += x[i]*x[i];\n\n/home/alexeyche/prog/dnn/dnn_project/spikework/kernels/entropy.cpp:\n   15      double acc = 0.0;\n   16      // double x_norm = 0.0, y_norm = 0.0;\n   17:     for(size_t i=0; i<x.size(); ++i) {\n   18          double denom = x[i]+y[i];\n   19          if(denom>1e-08) {\n\n/home/alexeyche/prog/dnn/dnn_project/spikework/kernels/rbf_dot.cpp:\n   18      double acc = 0.0;\n   19      // double x_norm = 0.0, y_norm = 0.0;\n   20:     for(size_t i=0; i<x.size(); ++i) {\n   21          acc += o.sigma*(x[i]-y[i])*(x[i] - y[i]);\n   22          // x_norm += x[i]*x[i];\n\n/home/alexeyche/prog/dnn/dnn_project/tools/mpl/mpl_main.cpp:\n  138          Stream(s, Stream::Binary).writeObject(&ts_rest);\n  139          double acc_error = 0;\n  140:         for(size_t vi=0; vi<ts->length(); ++vi) {\n  141              const double& orig_val = ts->getValueAtDim(vi, dimension);\n  142              double rest_val;\n\n/home/alexeyche/prog/dnn/dnn_project/tools/spikework/fft.cpp:\n   43      if(ts) {\n   44          int *dims = new int[ts->data.size()];\n   45:         for(size_t i=0; i<ts->data.size(); ++i) {\n   46              dims[i] = ts->data[i].values.size();\n   47          }\n\n/home/alexeyche/prog/dnn/dnn_project/tools/spikework/spikework.cpp:\n    6  int main(int argc, char **argv) {\n    7      vector<string> args;\n    8:     for(size_t i=1; i<argc; ++i) {\n    9          args.push_back(argv[i]);\n   10      }\n\n/home/alexeyche/prog/dnn/dnn_project/tools/tests/test_constants.cpp:\n    6  int main(int argc, char **argv) {\n    7      vector<string> s;\n    8:     for(size_t i=1; i<argc; ++i) {\n    9          s.push_back(argv[i]);\n   10      }\n\n/home/alexeyche/prog/dnn/r_package/Rdnn/src/Makevars:\n   26  ##################################################################################################\n   27  \n   28: PKG_CXXFLAGS = -std=c++11\n   29  \n   30  PKG_CPPFLAGS=-I\"/home/alexeyche/dnn/include\"\n\n/home/alexeyche/prog/dnn/r_package/Rdnn/src/Makevars.in:\n    1: PKG_CXXFLAGS = -std=c++11\n    2  \n    3  PKG_CPPFLAGS=-I\"@DNN_INCLUDE@\"\n\n/home/alexeyche/prog/dnn/r_package/Rdnn/src/RConstants.h:\n   34              Rcpp::stop(\"Expecting names list as second argument\");\n   35          }\n   36:         for (size_t i = 0; i < l.size(); ++i) {\n   37              string key = CHAR(STRING_ELT(names, i));\n   38  \n   ..\n  129                  itr = json_spec_json.RemoveMember(itr);\n  130              } else {\n  131:                 ++itr;\n  132              }\n  133          }\n\n/home/alexeyche/prog/dnn/r_package/Rdnn/src/RGammatoneFB.h:\n   21          vector<double> xv = Rcpp::as<vector<double>>(x);\n   22          size_t i=0;\n   23:         for(auto it = freqs.begin(); it != freqs.end(); ++it) {\n   24              vector<double> out_f;\n   25              GammatoneFilter f( (verbose>0) ? GammatoneFilter::Options::Full : GammatoneFilter::Options::OnlyMembrane);\n   26  \n   27              f.calc(xv, sampling_rate, *it, hrect);\n   28:             for(size_t j=0; j<f.membrane.size(); ++j) {\n   29                  membrane(i,j) = f.membrane[j];\n   30              }\n   ..\n   35                  inst_freq.push_back(f.inst_freq);\n   36              }\n   37:             ++i;\n   38          }\n   39          Rcpp::List list_out;\n\n/home/alexeyche/prog/dnn/r_package/Rdnn/src/RProto.cpp:\n   24              ts->dim_info.size = m.nrow();\n   25              ts->data.resize(ts->dim_info.size);\n   26:             for(size_t i=0; i<m.nrow(); ++i) {\n   27:                 for(size_t j=0; j<m.ncol(); ++j) {\n   28                      ts->data[i].values.push_back(m(i,j));\n   29                  }\n   ..\n   55          Ptr<DoubleMatrix> r = Factory::inst().createObject<DoubleMatrix>();\n   56          r->allocate(m.nrow(), m.ncol());\n   57:         for(size_t i=0; i<m.nrow(); ++i) {\n   58:             for(size_t j=0; j<m.ncol(); ++j) {\n   59                  r->setElement(i,j, m(i,j));\n   60              }\n\n/home/alexeyche/prog/dnn/r_package/Rdnn/src/RProto.h:\n  130  \n  131              Rcpp::NumericMatrix ts_vals(od->dim(), od->length());\n  132:             for(size_t i=0; i<od->data.size(); ++i) {\n  133:                 for(size_t j=0; j<od->data[i].values.size(); ++j) {\n  134                      ts_vals(i, j) = od->data[i].values[j];\n  135                  }\n  ...\n  183  \n  184              Rcpp::NumericMatrix rm(m->nrow(), m->ncol());\n  185:             for(size_t i=0; i<m->nrow(); ++i) {\n  186:                 for(size_t j=0; j<m->ncol(); ++j) {\n  187                      rm(i,j) = m->getElement(i,j);\n  188                  }\n  ...\n  192                  Rcpp::CharacterVector cols(m->colLabelsIds().size());\n  193  \n  194:                 for(size_t el_i=0; el_i<m->rowLabelsIds().size(); ++el_i) {\n  195                      size_t lid = m->rowLabelsIds()[el_i];\n  196                      rows(el_i) = m->uniqueLabels()[lid];\n  197                  }\n  198:                 for(size_t el_i=0; el_i<m->colLabelsIds().size(); ++el_i) {\n  199                      size_t lid = m->colLabelsIds()[el_i];\n  200                      cols(el_i) = m->uniqueLabels()[lid];\n  ...\n  274          Rcpp::NumericVector s = matches_l[\"s\"];\n  275          Rcpp::IntegerVector fi = matches_l[\"fi\"];\n  276:         for(size_t i=0; i<t.size(); ++i) {\n  277              matches.push_back(\n  278                  FilterMatch(fi[i], s[i], t[i])\n\n/home/alexeyche/prog/dnn/r_package/Rdnn/src/RSim.cpp:\n   20  \n   21      auto slice = Factory::inst().getObjectsSlice(obj_name);\n   22:     for(auto it=slice.first; it != slice.second; ++it) {\n   23          Factory::inst().getObject(it)->setAsInput(\n   24              ts\n   ..\n   46  \n   47      auto slice = Factory::inst().getObjectsSlice(obj_name);\n   48:     for(auto it=slice.first; it != slice.second; ++it) {\n   49          Factory::inst().getObject(it)->setAsInput(\n   50              sp_l\n\n634 matches across 120 files\n\n\nSearching 329 files for \"InputInfo\" (regex)\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/inputs/input.h:\n   46  \n   47  /*@GENERATE_PROTO@*/\n   48: struct InputInfo : public Serializable<Protos::InputInfo> {\n   49:     InputInfo() : localId(0) {}\n   50  \n   51      void serial_process() {\n   ..\n   66              return;\n   67          }\n   68:         InputInfo info;\n   69          if (mode == ProcessingOutput) {\n   70              info.localId = localId();\n   71          }\n   72:         (*this) << \"InputInfo: \" << info;\n   73          (*this) << \"State: \" << s << Self::end;\n   74      }\n\n/home/alexeyche/prog/dnn/dnn_project/dnn/protos/input.proto:\n    1  package Protos;\n    2  \n    3: message InputInfo {\n    4      required uint32 localId = 1;\n    5  }\n\n6 matches across 2 files\n",
			"settings":
			{
				"buffer_size": 128419,
				"line_ending": "Unix",
				"name": "Find Results",
				"scratch": true
			}
		},
		{
			"file": "dnn_project/dnn/inputs/input.h",
			"settings":
			{
				"buffer_size": 1695,
				"line_ending": "Unix"
			}
		},
		{
			"file": "dnn_project/dnn/base/register.x",
			"settings":
			{
				"buffer_size": 1321,
				"line_ending": "Unix"
			}
		},
		{
			"file": "dnn_project/dnn/base/constants.cpp",
			"settings":
			{
				"buffer_size": 3438,
				"line_ending": "Unix"
			}
		},
		{
			"file": "dnn_project/dnn/reinforcements/input_classifier.h",
			"settings":
			{
				"buffer_size": 874,
				"line_ending": "Unix"
			}
		},
		{
			"file": "dnn_project/dnn/inputs/input_time_series.h",
			"settings":
			{
				"buffer_size": 1946,
				"line_ending": "Unix"
			}
		},
		{
			"file": "dnn_project/dnn/util/time_series.h",
			"settings":
			{
				"buffer_size": 9023,
				"line_ending": "Unix"
			}
		},
		{
			"file": "dnn_project/dnn/sim/sim.cpp",
			"settings":
			{
				"buffer_size": 4478,
				"line_ending": "Unix"
			}
		},
		{
			"file": "dnn_project/dnn/sim/builder.cpp",
			"settings":
			{
				"buffer_size": 5217,
				"line_ending": "Unix"
			}
		},
		{
			"file": "dnn_project/dnn/sim/network.h",
			"settings":
			{
				"buffer_size": 2056,
				"line_ending": "Unix"
			}
		},
		{
			"file": "dnn_project/dnn/util/spikes_list.h",
			"settings":
			{
				"buffer_size": 1894,
				"line_ending": "Unix"
			}
		},
		{
			"file": "dnn_project/tools/dnn_sim/dnn_sim.cpp",
			"settings":
			{
				"buffer_size": 3112,
				"line_ending": "Unix"
			}
		},
		{
			"file": "dnn_project/dnn/neurons/spike_sequence_neuron.h",
			"settings":
			{
				"buffer_size": 2641,
				"line_ending": "Unix"
			}
		}
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
	],
	"build_system": "",
	"build_system_choices":
	[
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 159.0,
		"last_filter": "inst",
		"selected_items":
		[
			[
				"inst",
				"Package Control: Install Package"
			],
			[
				"Packa",
				"Package Control: Remove Package"
			]
		],
		"width": 449.0
	},
	"console":
	{
		"height": 146.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = 'eb2297e1a458f27d836c04bb0cbaf282' + 'd0e7a3098092775ccb37ca9d6b2e4b7d'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/home/alexeyche/prog/dnn/dnn_project",
		"/home/alexeyche/prog/dnn/dnn_project/dnn",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/reinforcements",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/R"
	],
	"file_history":
	[
<<<<<<< HEAD
		"/home/alexeyche/prog/dnn/dnn_project/dnn/io/stream.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/json.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/json.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/base/constants.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/base/constants.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/base/register.x",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/neurons/spike_neuron.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/reinforcements/input_classifier.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/synapses/static_synapse.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/statistics.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/sim/reward_control.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/sim/builder.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/sim/sim.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/learning_rules/optimal_stdp.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/sim/builder.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/sim/sim.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/neurons/spike_neuron.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/shapelets/stats.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/reinforcements/reinforcement.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/weight_normalizations/sliding_ltd.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/weight_normalizations/weight_normalization.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/sim/global_ctx.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/act_functions/determ.h",
		"/home/alexeyche/prog/dnn/dnn_project/tools/dnn_sim/dnn_sim.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/base/factory.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/learning_rules/optimal_stdp.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/base/register_impl.x",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/weight_normalizations/nonlinear_min_max.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/sim/network.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/neurons/spike_sequence_neuron.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/util.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/util.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/learning_rules/learning_rule.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/CMakeLists.txt",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/reinforcements/CMakeLists.txt",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/base/base.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/time_series.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/io/serialize.h",
		"/home/alexeyche/prog/snn_sim/sources/snnlib/reinforcement/input_classification.h",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/RProto.h",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/RProto.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/const.json",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/spikes_list.h",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/RSim.h",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/RSim.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/inputs/input_time_series.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/neurons/leaky_integrate_and_fire.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/neurons/srm_neuron.h",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernel.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/CMakeLists.txt",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/option_parser.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/option_parser.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/protos/spike_sequence_neuron.proto",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/accum.h",
		"/home/alexeyche/prog/dnn/dnn_project/tools/CMakeLists.txt",
		"/home/alexeyche/prog/dnn/dnn_project/shapelets/subsequence.h",
		"/home/alexeyche/prog/dnn/dnn_project/tools/tests/CMakeLists.txt",
		"/home/alexeyche/prog/dnn/dnn_project/tools/tests/test_constants.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/details/format.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/base/CMakeLists.txt",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/ptr.h",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/R/zzz.R",
		"/home/alexeyche/prog/dnn/r_package/r_scripts/sim_api/fb_sim.R",
=======
		"/home/alexeyche/prog/dnn/dnn_project/dnn/sim/builder.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/sim/sim.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/sim/global_ctx.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/ptr.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/protos/input.proto",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/reinforcements/reinforcement.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/neurons/spike_sequence_neuron.h",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/RSim.h",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/RSim.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernel.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernel.h",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/conv.cpp",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/RMpl.h",
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
		"/home/alexeyche/prog/dnn/dnn_project/dnn/base/factory.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/util.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/util.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/time_series.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/inputs/input_time_series.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/io/serialize.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/ptr.cpp",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/util.cpp",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/util.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/CMakeLists.txt",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/time_series.h",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/RProto.h",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/RKernel.h",
<<<<<<< HEAD
		"/home/alexeyche/prog/dnn/dnn_project/dnn/act_functions/act_function.h",
=======
		"/home/alexeyche/prog/dnn/dnn_project/dnn/base/factory.cpp",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/RProto.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/io/stream.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/io/stream.cpp",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/R/dataset_preparings.R",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/RKernel.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/sim/builder.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/sim/network.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/details/logger_impl.h",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/spikework.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/io_worker.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/io_worker.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/log/log.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/details/spdlog_impl.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/learning_rules/learning_rule.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/spikes_list.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/neurons/spike_neuron.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/inputs/input.h",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/Makevars.in",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernels/shoe.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernels/entropy.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernels/rbf_dot.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernels/anova_dot.cpp",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/R/zzz.R",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/R/env.R",
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/mod.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/base/constants.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/matrix.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/sim/sim.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/gammatone_fb.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/neurons/leaky_integrate_and_fire.h",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/mod.h",
		"/home/alexeyche/prog/dnn/dnn_project/CMakeLists.txt",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/CMakeLists.txt",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/RConstants.h",
<<<<<<< HEAD
		"/home/alexeyche/prog/dnn/dnn_project/dnn/core.h",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/common.h",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/RConstants.cpp",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/Makevars.in",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/base/gen_const.sh",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/protos/CMakeLists.txt",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/base/const.xdd",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/spikework.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/conv.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/base/deduce_type_impl.x",
		"/home/alexeyche/prog/dnn/dnn_project/mpl/mpl.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/io/stream.cpp",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/mod.h",
		"/home/alexeyche/prog/dnn/dnn_project/shapelets/shapelets_algo.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/interfaced_ptr.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/io/serialize.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/mpl/mpl_register.x",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/io_worker.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/tools/mpl/mpl_main.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/tools/shapelets/shapelets.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/time_series.cpp",
=======
		"/home/alexeyche/prog/dnn/dnn_project/dnn/base/base.h",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/spikework.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/act_functions/determ.h",
		"/home/alexeyche/prog/dnn/const.json",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/neurons/spike_neuron.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/protos/std_synapse.proto",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/act_functions/act_function.h",
		"/home/alexeyche/prog/dnn/dnn_project/tools/dnn_sim/dnn_sim.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/learning_rules/stdp.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/act_functions/exp_threshold.h",
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
		"/home/alexeyche/prog/dnn/dnn_project/shapelets/shapelets_algo.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/shapelets/shapelets_algo.h",
		"/home/alexeyche/prog/dnn/dnn_project/shapelets/orderline.cpp",
		"/home/alexeyche/prog/alexeyche-junk/scala/insertion_sort.scala",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/fft.cpp",
<<<<<<< HEAD
		"/home/alexeyche/prog/dnn/dnn_project/shapelets/shapelets_config.h",
		"/home/alexeyche/prog/dnn/dnn_project/shapelets/shapelet_register.x",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/spikes_list.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/connections/connection.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/sim/CMakeLists.txt",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernels/shoe.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/spikework.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/CMakeLists.txt",
		"/home/alexeyche/prog/dnn/dnn_project/shapelets/register.x",
		"/home/alexeyche/prog/dnn/dnn_project/tools/spikework/spikework.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/base/type_deducer.h",
		"/home/alexeyche/temp.x",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/base/forward_declarations.x",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/matrix.h",
=======
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/func_param_parser.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernels/rbf_dot.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/func_param_parser.h",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernel_factory.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernel_factory.h",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernels/shoe.h",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/CMakeLists.txt",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernels/CMakeLists.txt",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/option_parser.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/option_parser.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/fastapprox/fastpow.h",
<<<<<<< HEAD
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/fastapprox/fastexp.h"
=======
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/fastapprox/fastexp.h",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernels/anova_dot.h",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernels/entropy.h",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernels/dot.h",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernels/dot.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernels/epsp.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernels/epsp.h",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/worker.h",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/gram.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/gram.h",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/conv.h",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/fft.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/core.h",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernel_defs.h",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernel_defs.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/tools/spikework/spikework.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/pretty_print.h",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernel_old.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernel_old.h",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernels.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/kernels.h",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/read.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/act_vector.h",
		"/home/alexeyche/prog/dnn/dnn_project/tools/mpl/mpl_main.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/util/spikes_list.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/mpl/mpl.h",
		"/home/alexeyche/prog/dnn/dnn_project/mpl/mpl.cpp",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/R/util.R",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/RGammatoneFB.h",
		"/home/alexeyche/prog/dnn/dnn_project/tools/shapelets/shapelets.cpp",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/common.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/details/format.h",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/spdlog/details/format.cc",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/Makevars",
		"/home/alexeyche/prog/dnn/r_package/Rdnn/src/RMpl.cpp",
		"/home/alexeyche/prog/dnn/dnn_project/spikework/io_processor.cpp",
		"/home/alexeyche/.config/sublime-text-2/Packages/CTags/Default.sublime-keymap",
		"/home/alexeyche/prog/dnn/dnn_project/tools/mpl/CMakeLists.txt",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/kiss_fft/kiss_fftndr.c",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/contrib/kiss_fft/kiss_fftr.c",
		"/home/alexeyche/prog/dnn/dnn_project/dnn/protos/matrix.proto"
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
	],
	"find":
	{
		"height": 35.0
	},
	"find_in_files":
	{
<<<<<<< HEAD
		"height": 90.0,
=======
		"height": 93.0,
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
		"where_history":
		[
			"",
			"/home/alexeyche/prog/dnn/r_package/Rdnn/src",
			"",
			"/home/alexeyche/prog/dnn/r_package/Rdnn/src",
			"",
			"/home/alexeyche/prog/dnn/dnn_project/shapelets",
			""
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
<<<<<<< HEAD
			"sim_info",
			"InputClassfier",
			"ReinforcementBase",
			"InputClassifier",
			"Null object from constants",
			"reinfo",
			"getString",
			"reinforcements",
			"NonLinearMinMax",
			"ActFunction",
			"float",
			"fill",
			"obj",
			"getCachedObject",
			"parse",
			"parseJ",
			"read",
			"SimInfo",
			"reco",
			"Can't re",
			"Can't recognize",
			"cast",
			"getVal",
			"Errors while finding field",
			"const_json",
			"replaceStr",
			"convertMatchesToSpikes",
			"createDynamic",
			"createDynamicObject",
			"convertToR",
			"destroy",
			"destroy\\(\\)",
			"destr",
			"destroy",
			"setCoordinates",
			"localId",
			"setAsIn",
			"DEBUG_LEVEL",
			"Calling inapropriate default interface function",
			"Calling inapproCalling inapropriate default interface function",
			"Calling inappro",
			"FindMember",
			"typ",
			"start_w",
			"conta",
			"Rf_isNull",
			"Rf_isNulll",
			"SetBoolean",
			"parseStr",
			"parse",
			"parseJs",
			"cptr",
			"SetString",
			"GetStr",
			"SetStr",
			"dnn::",
			"parseStr",
			"0x00",
			"string",
			"parse",
			"OptMods",
			"getHeader",
			"Trying to get header from empty messages",
			"Statistics",
			"Statist",
			"setAsInput",
			"setA",
			"ser",
			"I",
			"setA",
			"objects",
			"facto",
			"convertMatchesToSpikes",
			"conver",
			"ret",
=======
			"getInput",
			"getTime",
			"InputIn",
			"InputInfo",
			"\\+\\++",
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
			"convertBack",
			"kern_res",
			"thread",
			"set_level",
			"deque",
			"exp",
			"Got input spike",
			"reset",
			"convertToList",
			"SEXp",
			"DoubleMa",
			"dt",
			"what",
			"L_DE",
			"abs",
			"convertTo",
			"Serial",
			"Seri",
			"convertB",
			"conver",
			"treshold",
			"convertBack",
			"getDeaultLayerConf",
			"getLocalId",
			"serial",
			"createObject",
			"funDelegate",
			"name\\(",
			"name",
			"global_neuron_index",
			"setColLabel",
			"which",
			"kernel_ma",
			"RbfDot",
			"Rbf",
<<<<<<< HEAD
			"Dot"
=======
			"Dot",
			"const",
			"norm",
			"norma",
			"map",
			"eq_spl",
			"KernelProcessor",
			"setNo",
			"erase",
			"opts",
			"erase",
			"remove",
			"processor",
			"Preprocessor",
			"proc",
			"processor",
			"proc_map",
			"proc",
			"processors",
			"KernelOldProcessor",
			"\\<Kernel",
			"createOb",
			"convertToL",
			"conver",
			"Can't recogniz",
			"NumericMatrix",
			"wrap",
			"std::copy",
			"copy",
			"x[",
			"x\\[",
			"x",
			"setF",
			"norm",
			"x[x",
			"setNoColors",
			"FMT_HEADER_ONLY",
			"format.cc",
			"ERR",
			"Filter",
			"convertFi",
			"converFi",
			"convertBack",
			"getCachedObject",
			"createOb",
			"Error to cast",
			"error",
			"Error",
			"Error ",
			"Error cast object ",
			"MatchingPursuitConfig",
			"dnn::",
			"Match",
			"assertAnotherTs",
			"kiss_fftr_cfg",
			"cfg_nd",
			"kiss_fftnd",
			"dim()",
			"dim",
			"data",
			"printNow",
			"printH",
			"Fur",
			"furth",
			"maxPossibleFurtherInformationGain",
			"Furh",
			"maxPo",
			"insert",
			"Fur",
			"calcEn",
			"left",
			"protobinSave",
			"protob",
			"before",
			"p.split_dist",
			"left",
			"map",
			"make",
			"subsequence",
			"d\\.",
			"Right",
			"Left",
			"Printa",
			"left",
			"gapDist",
			"left_classes_hist",
			"left",
			"class_counts"
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": false,
		"regex": true,
		"replace_history":
		[
<<<<<<< HEAD
			"InputClassfier",
			"Reinforcement",
			"double",
			"createObject",
			"REG_TYPE_WITH_CONST_AND_STATE",
=======
			"convertToR",
			"threshold",
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
			"Shoe",
			"Anova",
			"RbfDot",
			"Entropy",
			"KernelPreprocessor",
			"worker",
			"Processor",
			"worker",
			"work_map",
			"workers",
			"KernelProcessor",
			"KernelOld",
			"",
			"right",
			"after",
			"p.dist",
			"right",
			"New",
			"Base",
			"right",
			"",
			"right",
			"Subsequence",
			"Stats",
			"",
			"ReadProcessor",
			"values",
			"Conv",
			"TimeSeriesBase::info",
			"TimeSeriesBase::dim_info",
			"",
			"C_",
			"SRMNeuron",
			"n\\.",
			"const SpikeNeuronBase &n",
			"n.ref().",
			"ExpTheshold",
			";\n;",
			"SRMNeuron",
			"SpikeNeuronBase",
			"OptimalStdp",
			"Bike",
			"bike",
			"Bike",
			"'",
			"",
			"= m->",
			"rem_server_port",
			"td",
			"patch_stat",
			"self.args.",
			"self.args",
			"",
			"host",
			"output",
			"host",
			"output",
			"host",
			"",
			"StdpTime",
			"DifferenceOfGaussians",
			"SpikeSequenceNeuron",
			"InputFileNeuron",
			"}}",
			"{{",
			"}}",
			"{{",
			"worker",
			"InterfacedPtr<SpikeNeuronBase>",
			"InterfacedPtr2<SpikeNeuronBase>",
			"self.working_dir",
			"Stdp",
			"LearningRule",
			"out",
			"AdaptIntegrateAndFire",
			"messages->",
			"deleteCurrentMessage",
			"\\1currentMessage"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"sheets":
			[
<<<<<<< HEAD
=======
				{
					"buffer": 0,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 128419,
						"regions":
						{
							"match":
							{
								"flags": 112,
								"regions":
								[
									[
										448,
										450
									],
									[
										1129,
										1131
									],
									[
										1237,
										1239
									],
									[
										1358,
										1360
									],
									[
										1991,
										1993
									],
									[
										2030,
										2032
									],
									[
										2076,
										2078
									],
									[
										2136,
										2138
									],
									[
										2166,
										2168
									],
									[
										2238,
										2240
									],
									[
										2298,
										2300
									],
									[
										2304,
										2306
									],
									[
										2955,
										2957
									],
									[
										2994,
										2996
									],
									[
										3562,
										3564
									],
									[
										3622,
										3624
									],
									[
										3652,
										3654
									],
									[
										3724,
										3726
									],
									[
										3784,
										3786
									],
									[
										3790,
										3792
									],
									[
										4503,
										4505
									],
									[
										5227,
										5229
									],
									[
										5856,
										5858
									],
									[
										5977,
										5979
									],
									[
										6478,
										6480
									],
									[
										6670,
										6672
									],
									[
										6853,
										6855
									],
									[
										7085,
										7087
									],
									[
										7312,
										7314
									],
									[
										7549,
										7551
									],
									[
										7899,
										7901
									],
									[
										8172,
										8174
									],
									[
										8608,
										8610
									],
									[
										8973,
										8975
									],
									[
										9251,
										9253
									],
									[
										9456,
										9458
									],
									[
										9689,
										9691
									],
									[
										9713,
										9715
									],
									[
										9854,
										9856
									],
									[
										9968,
										9970
									],
									[
										10079,
										10081
									],
									[
										10326,
										10328
									],
									[
										10334,
										10336
									],
									[
										10342,
										10344
									],
									[
										10350,
										10352
									],
									[
										10358,
										10360
									],
									[
										10525,
										10527
									],
									[
										10588,
										10590
									],
									[
										10755,
										10757
									],
									[
										10871,
										10873
									],
									[
										11066,
										11068
									],
									[
										11118,
										11120
									],
									[
										11359,
										11361
									],
									[
										11618,
										11620
									],
									[
										11745,
										11747
									],
									[
										11775,
										11777
									],
									[
										11907,
										11909
									],
									[
										12196,
										12198
									],
									[
										12366,
										12368
									],
									[
										12566,
										12568
									],
									[
										12725,
										12727
									],
									[
										12869,
										12871
									],
									[
										13118,
										13120
									],
									[
										13289,
										13291
									],
									[
										13499,
										13501
									],
									[
										13775,
										13777
									],
									[
										13985,
										13987
									],
									[
										14329,
										14331
									],
									[
										14374,
										14376
									],
									[
										14557,
										14559
									],
									[
										14600,
										14602
									],
									[
										14911,
										14913
									],
									[
										15096,
										15098
									],
									[
										15284,
										15286
									],
									[
										15575,
										15577
									],
									[
										15789,
										15791
									],
									[
										15999,
										16001
									],
									[
										16278,
										16280
									],
									[
										16572,
										16574
									],
									[
										16710,
										16712
									],
									[
										16989,
										16991
									],
									[
										16997,
										16999
									],
									[
										17005,
										17007
									],
									[
										17013,
										17015
									],
									[
										17021,
										17023
									],
									[
										17160,
										17162
									],
									[
										17239,
										17241
									],
									[
										17444,
										17446
									],
									[
										17587,
										17589
									],
									[
										17879,
										17881
									],
									[
										18071,
										18073
									],
									[
										18252,
										18254
									],
									[
										18295,
										18297
									],
									[
										18542,
										18544
									],
									[
										18793,
										18795
									],
									[
										19042,
										19044
									],
									[
										19293,
										19295
									],
									[
										19546,
										19548
									],
									[
										19797,
										19799
									],
									[
										20050,
										20052
									],
									[
										20297,
										20299
									],
									[
										20553,
										20555
									],
									[
										20816,
										20818
									],
									[
										21064,
										21066
									],
									[
										21351,
										21353
									],
									[
										21702,
										21704
									],
									[
										21965,
										21967
									],
									[
										22127,
										22129
									],
									[
										22453,
										22455
									],
									[
										22772,
										22774
									],
									[
										22978,
										22980
									],
									[
										22984,
										22986
									],
									[
										23096,
										23098
									],
									[
										23126,
										23128
									],
									[
										23338,
										23340
									],
									[
										23686,
										23688
									],
									[
										23927,
										23929
									],
									[
										24122,
										24124
									],
									[
										24459,
										24461
									],
									[
										24854,
										24856
									],
									[
										25104,
										25106
									],
									[
										25338,
										25340
									],
									[
										25545,
										25547
									],
									[
										25766,
										25768
									],
									[
										26022,
										26024
									],
									[
										26355,
										26357
									],
									[
										26595,
										26597
									],
									[
										26900,
										26902
									],
									[
										27334,
										27336
									],
									[
										27521,
										27523
									],
									[
										27731,
										27733
									],
									[
										27986,
										27988
									],
									[
										28173,
										28175
									],
									[
										28384,
										28386
									],
									[
										28637,
										28639
									],
									[
										28886,
										28888
									],
									[
										29103,
										29105
									],
									[
										29344,
										29346
									],
									[
										29546,
										29548
									],
									[
										29787,
										29789
									],
									[
										30035,
										30037
									],
									[
										30292,
										30294
									],
									[
										30514,
										30516
									],
									[
										30731,
										30733
									],
									[
										30868,
										30870
									],
									[
										31058,
										31060
									],
									[
										31225,
										31227
									],
									[
										31443,
										31445
									],
									[
										31598,
										31600
									],
									[
										31750,
										31752
									],
									[
										31918,
										31920
									],
									[
										32070,
										32072
									],
									[
										32181,
										32183
									],
									[
										32337,
										32339
									],
									[
										32533,
										32535
									],
									[
										32743,
										32745
									],
									[
										32989,
										32991
									],
									[
										33203,
										33205
									],
									[
										33418,
										33420
									],
									[
										33640,
										33642
									],
									[
										33830,
										33832
									],
									[
										34020,
										34022
									],
									[
										34243,
										34245
									],
									[
										34567,
										34569
									],
									[
										34947,
										34949
									],
									[
										35167,
										35169
									],
									[
										35389,
										35391
									],
									[
										35599,
										35601
									],
									[
										35805,
										35807
									],
									[
										36102,
										36104
									],
									[
										36352,
										36354
									],
									[
										36544,
										36546
									],
									[
										36739,
										36741
									],
									[
										36976,
										36978
									],
									[
										37101,
										37103
									],
									[
										37324,
										37326
									],
									[
										37519,
										37521
									],
									[
										37753,
										37755
									],
									[
										37955,
										37957
									],
									[
										38146,
										38148
									],
									[
										38456,
										38458
									],
									[
										38616,
										38618
									],
									[
										38897,
										38899
									],
									[
										39106,
										39108
									],
									[
										39307,
										39309
									],
									[
										39514,
										39516
									],
									[
										39824,
										39826
									],
									[
										39948,
										39950
									],
									[
										40175,
										40177
									],
									[
										40451,
										40453
									],
									[
										40630,
										40632
									],
									[
										40822,
										40824
									],
									[
										40925,
										40927
									],
									[
										41085,
										41087
									],
									[
										41118,
										41120
									],
									[
										41250,
										41252
									],
									[
										41283,
										41285
									],
									[
										41345,
										41347
									],
									[
										41565,
										41567
									],
									[
										41752,
										41754
									],
									[
										41922,
										41924
									],
									[
										42137,
										42139
									],
									[
										42217,
										42219
									],
									[
										42300,
										42302
									],
									[
										42343,
										42345
									],
									[
										42508,
										42510
									],
									[
										42592,
										42594
									],
									[
										42679,
										42681
									],
									[
										42722,
										42724
									],
									[
										42785,
										42787
									],
									[
										42828,
										42830
									],
									[
										42875,
										42877
									],
									[
										42918,
										42920
									],
									[
										43082,
										43084
									],
									[
										43128,
										43130
									],
									[
										43215,
										43217
									],
									[
										43432,
										43434
									],
									[
										43475,
										43477
									],
									[
										43522,
										43524
									],
									[
										43565,
										43567
									],
									[
										43612,
										43614
									],
									[
										43655,
										43657
									],
									[
										43702,
										43704
									],
									[
										43745,
										43747
									],
									[
										43923,
										43925
									],
									[
										44067,
										44069
									],
									[
										44151,
										44153
									],
									[
										44238,
										44240
									],
									[
										44285,
										44287
									],
									[
										44447,
										44449
									],
									[
										44539,
										44541
									],
									[
										44634,
										44636
									],
									[
										44681,
										44683
									],
									[
										44752,
										44754
									],
									[
										44799,
										44801
									],
									[
										44850,
										44852
									],
									[
										44897,
										44899
									],
									[
										45028,
										45030
									],
									[
										45111,
										45113
									],
									[
										45198,
										45200
									],
									[
										45281,
										45283
									],
									[
										45368,
										45370
									],
									[
										45451,
										45453
									],
									[
										45537,
										45539
									],
									[
										45619,
										45621
									],
									[
										45682,
										45684
									],
									[
										45725,
										45727
									],
									[
										45772,
										45774
									],
									[
										45815,
										45817
									],
									[
										45862,
										45864
									],
									[
										45905,
										45907
									],
									[
										45952,
										45954
									],
									[
										45995,
										45997
									],
									[
										46126,
										46128
									],
									[
										46285,
										46287
									],
									[
										46331,
										46333
									],
									[
										46434,
										46436
									],
									[
										46592,
										46594
									],
									[
										46638,
										46640
									],
									[
										46835,
										46837
									],
									[
										46881,
										46883
									],
									[
										46931,
										46933
									],
									[
										46977,
										46979
									],
									[
										47130,
										47132
									],
									[
										47173,
										47175
									],
									[
										47220,
										47222
									],
									[
										47263,
										47265
									],
									[
										47310,
										47312
									],
									[
										47353,
										47355
									],
									[
										47400,
										47402
									],
									[
										47443,
										47445
									],
									[
										47490,
										47492
									],
									[
										47533,
										47535
									],
									[
										47580,
										47582
									],
									[
										47623,
										47625
									],
									[
										47670,
										47672
									],
									[
										47713,
										47715
									],
									[
										47760,
										47762
									],
									[
										47803,
										47805
									],
									[
										47967,
										47969
									],
									[
										48178,
										48180
									],
									[
										48400,
										48402
									],
									[
										48704,
										48706
									],
									[
										48999,
										49001
									],
									[
										49213,
										49215
									],
									[
										49407,
										49409
									],
									[
										49644,
										49646
									],
									[
										49778,
										49780
									],
									[
										49982,
										49984
									],
									[
										50145,
										50147
									],
									[
										50383,
										50385
									],
									[
										50509,
										50511
									],
									[
										50634,
										50636
									],
									[
										50885,
										50887
									],
									[
										51214,
										51216
									],
									[
										51613,
										51615
									],
									[
										52015,
										52017
									],
									[
										52414,
										52416
									],
									[
										52813,
										52815
									],
									[
										53213,
										53215
									],
									[
										53630,
										53632
									],
									[
										54048,
										54050
									],
									[
										54460,
										54462
									],
									[
										54815,
										54817
									],
									[
										55013,
										55015
									],
									[
										55180,
										55182
									],
									[
										55415,
										55417
									],
									[
										55625,
										55627
									],
									[
										55900,
										55902
									],
									[
										56115,
										56117
									],
									[
										56344,
										56346
									],
									[
										56498,
										56500
									],
									[
										56772,
										56774
									],
									[
										56988,
										56990
									],
									[
										57210,
										57212
									],
									[
										57337,
										57339
									],
									[
										57512,
										57514
									],
									[
										57656,
										57658
									],
									[
										57799,
										57801
									],
									[
										58005,
										58007
									],
									[
										58227,
										58229
									],
									[
										58347,
										58349
									],
									[
										58574,
										58576
									],
									[
										58824,
										58826
									],
									[
										58991,
										58993
									],
									[
										59188,
										59190
									],
									[
										59446,
										59448
									],
									[
										59586,
										59588
									],
									[
										59695,
										59697
									],
									[
										59855,
										59857
									],
									[
										60070,
										60072
									],
									[
										60255,
										60257
									],
									[
										60419,
										60421
									],
									[
										60674,
										60676
									],
									[
										60717,
										60719
									],
									[
										60905,
										60907
									],
									[
										61064,
										61066
									],
									[
										61231,
										61233
									],
									[
										61475,
										61477
									],
									[
										61690,
										61692
									],
									[
										61894,
										61896
									],
									[
										61919,
										61921
									],
									[
										62135,
										62137
									],
									[
										62284,
										62286
									],
									[
										62652,
										62654
									],
									[
										63000,
										63002
									],
									[
										63234,
										63236
									],
									[
										63542,
										63544
									],
									[
										63770,
										63772
									],
									[
										63991,
										63993
									],
									[
										64307,
										64309
									],
									[
										64438,
										64440
									],
									[
										64628,
										64630
									],
									[
										64819,
										64821
									],
									[
										64867,
										64869
									],
									[
										64982,
										64984
									],
									[
										65215,
										65217
									],
									[
										65263,
										65265
									],
									[
										65378,
										65380
									],
									[
										65649,
										65651
									],
									[
										65739,
										65741
									],
									[
										65967,
										65969
									],
									[
										66136,
										66138
									],
									[
										66300,
										66302
									],
									[
										66438,
										66440
									],
									[
										66558,
										66560
									],
									[
										66754,
										66756
									],
									[
										66825,
										66827
									],
									[
										66914,
										66916
									],
									[
										66950,
										66952
									],
									[
										67054,
										67056
									],
									[
										67206,
										67208
									],
									[
										67424,
										67426
									],
									[
										67751,
										67753
									],
									[
										68024,
										68026
									],
									[
										68186,
										68188
									],
									[
										68363,
										68365
									],
									[
										68421,
										68423
									],
									[
										68565,
										68567
									],
									[
										68796,
										68798
									],
									[
										69187,
										69189
									],
									[
										69595,
										69597
									],
									[
										70007,
										70009
									],
									[
										70404,
										70406
									],
									[
										70689,
										70691
									],
									[
										71092,
										71094
									],
									[
										71413,
										71415
									],
									[
										71778,
										71780
									],
									[
										72139,
										72141
									],
									[
										72295,
										72297
									],
									[
										72587,
										72589
									],
									[
										72999,
										73001
									],
									[
										73407,
										73409
									],
									[
										73816,
										73818
									],
									[
										74224,
										74226
									],
									[
										74635,
										74637
									],
									[
										75038,
										75040
									],
									[
										75449,
										75451
									],
									[
										75859,
										75861
									],
									[
										76281,
										76283
									],
									[
										76520,
										76522
									],
									[
										76719,
										76721
									],
									[
										76923,
										76925
									],
									[
										77260,
										77262
									],
									[
										77558,
										77560
									],
									[
										77972,
										77974
									],
									[
										78359,
										78361
									],
									[
										78540,
										78542
									],
									[
										78764,
										78766
									],
									[
										78952,
										78954
									],
									[
										79081,
										79083
									],
									[
										79268,
										79270
									],
									[
										79501,
										79503
									],
									[
										79693,
										79695
									],
									[
										80010,
										80012
									],
									[
										80296,
										80298
									],
									[
										80488,
										80490
									],
									[
										80722,
										80724
									],
									[
										80940,
										80942
									],
									[
										81133,
										81135
									],
									[
										81334,
										81336
									],
									[
										81471,
										81473
									],
									[
										81689,
										81691
									],
									[
										82092,
										82094
									],
									[
										82285,
										82287
									],
									[
										82445,
										82447
									],
									[
										82750,
										82752
									],
									[
										82888,
										82890
									],
									[
										83172,
										83174
									],
									[
										83399,
										83401
									],
									[
										83589,
										83591
									],
									[
										83670,
										83672
									],
									[
										83843,
										83845
									],
									[
										84115,
										84117
									],
									[
										84416,
										84418
									],
									[
										84767,
										84769
									],
									[
										85046,
										85048
									],
									[
										85207,
										85209
									],
									[
										85431,
										85433
									],
									[
										85550,
										85552
									],
									[
										85685,
										85687
									],
									[
										86053,
										86055
									],
									[
										86295,
										86297
									],
									[
										86629,
										86631
									],
									[
										86703,
										86705
									],
									[
										86763,
										86765
									],
									[
										86811,
										86813
									],
									[
										87184,
										87186
									],
									[
										87551,
										87553
									],
									[
										87854,
										87856
									],
									[
										88113,
										88115
									],
									[
										88462,
										88464
									],
									[
										88743,
										88745
									],
									[
										88949,
										88951
									],
									[
										89158,
										89160
									],
									[
										89417,
										89419
									],
									[
										89767,
										89769
									],
									[
										89920,
										89922
									],
									[
										90250,
										90252
									],
									[
										90688,
										90690
									],
									[
										90842,
										90844
									],
									[
										91144,
										91146
									],
									[
										91403,
										91405
									],
									[
										91732,
										91734
									],
									[
										92023,
										92025
									],
									[
										92296,
										92298
									],
									[
										92538,
										92540
									],
									[
										92938,
										92940
									],
									[
										93086,
										93088
									],
									[
										93135,
										93137
									],
									[
										93284,
										93286
									],
									[
										93373,
										93375
									],
									[
										93554,
										93556
									],
									[
										93794,
										93796
									],
									[
										94068,
										94070
									],
									[
										94256,
										94258
									],
									[
										94520,
										94522
									],
									[
										94709,
										94711
									],
									[
										94830,
										94832
									],
									[
										95030,
										95032
									],
									[
										95151,
										95153
									],
									[
										95459,
										95461
									],
									[
										95733,
										95735
									],
									[
										96044,
										96046
									],
									[
										96311,
										96313
									],
									[
										96373,
										96375
									],
									[
										96524,
										96526
									],
									[
										96729,
										96731
									],
									[
										97046,
										97048
									],
									[
										97331,
										97333
									],
									[
										97396,
										97398
									],
									[
										97680,
										97682
									],
									[
										97861,
										97863
									],
									[
										97993,
										97995
									],
									[
										98188,
										98190
									],
									[
										98446,
										98448
									],
									[
										98776,
										98778
									],
									[
										98840,
										98842
									],
									[
										99056,
										99058
									],
									[
										99247,
										99249
									],
									[
										99386,
										99388
									],
									[
										99555,
										99557
									],
									[
										99820,
										99822
									],
									[
										100045,
										100047
									],
									[
										100216,
										100218
									],
									[
										100312,
										100314
									],
									[
										100490,
										100492
									],
									[
										100683,
										100685
									],
									[
										100880,
										100882
									],
									[
										101124,
										101126
									],
									[
										101384,
										101386
									],
									[
										101439,
										101441
									],
									[
										101585,
										101587
									],
									[
										101779,
										101781
									],
									[
										101831,
										101833
									],
									[
										101934,
										101936
									],
									[
										102209,
										102211
									],
									[
										102475,
										102477
									],
									[
										102662,
										102664
									],
									[
										102927,
										102929
									],
									[
										103236,
										103238
									],
									[
										103659,
										103661
									],
									[
										103784,
										103786
									],
									[
										104025,
										104027
									],
									[
										104196,
										104198
									],
									[
										104393,
										104395
									],
									[
										104700,
										104702
									],
									[
										104877,
										104879
									],
									[
										105013,
										105015
									],
									[
										105318,
										105320
									],
									[
										105481,
										105483
									],
									[
										105617,
										105619
									],
									[
										105827,
										105829
									],
									[
										105834,
										105836
									],
									[
										106056,
										106058
									],
									[
										106063,
										106065
									],
									[
										106281,
										106283
									],
									[
										106288,
										106290
									],
									[
										106489,
										106491
									],
									[
										106496,
										106498
									],
									[
										106725,
										106727
									],
									[
										106813,
										106815
									],
									[
										107022,
										107024
									],
									[
										107228,
										107230
									],
									[
										107439,
										107441
									],
									[
										107710,
										107712
									],
									[
										107857,
										107859
									],
									[
										108041,
										108043
									],
									[
										108193,
										108195
									],
									[
										108288,
										108290
									],
									[
										108532,
										108534
									],
									[
										108797,
										108799
									],
									[
										109137,
										109139
									],
									[
										109487,
										109489
									],
									[
										109599,
										109601
									],
									[
										109895,
										109897
									],
									[
										110132,
										110134
									],
									[
										110430,
										110432
									],
									[
										110638,
										110640
									],
									[
										110828,
										110830
									],
									[
										111116,
										111118
									],
									[
										111328,
										111330
									],
									[
										111604,
										111606
									],
									[
										111805,
										111807
									],
									[
										112008,
										112010
									],
									[
										112426,
										112428
									],
									[
										112705,
										112707
									],
									[
										112973,
										112975
									],
									[
										113286,
										113288
									],
									[
										113510,
										113512
									],
									[
										113775,
										113777
									],
									[
										114005,
										114007
									],
									[
										114136,
										114138
									],
									[
										114329,
										114331
									],
									[
										114655,
										114657
									],
									[
										114817,
										114819
									],
									[
										115072,
										115074
									],
									[
										115350,
										115352
									],
									[
										115530,
										115532
									],
									[
										115777,
										115779
									],
									[
										115850,
										115852
									],
									[
										116063,
										116065
									],
									[
										116293,
										116295
									],
									[
										116516,
										116518
									],
									[
										116521,
										116523
									],
									[
										116800,
										116802
									],
									[
										116805,
										116807
									],
									[
										117127,
										117129
									],
									[
										117255,
										117257
									],
									[
										117497,
										117499
									],
									[
										117693,
										117695
									],
									[
										117877,
										117879
									],
									[
										118074,
										118076
									],
									[
										118287,
										118289
									],
									[
										118522,
										118524
									],
									[
										118879,
										118881
									],
									[
										119009,
										119011
									],
									[
										119313,
										119315
									],
									[
										119571,
										119573
									],
									[
										119634,
										119636
									],
									[
										119963,
										119965
									],
									[
										120249,
										120251
									],
									[
										120360,
										120362
									],
									[
										120486,
										120488
									],
									[
										120822,
										120824
									],
									[
										121142,
										121144
									],
									[
										121422,
										121424
									],
									[
										121690,
										121692
									],
									[
										121952,
										121954
									],
									[
										122219,
										122221
									],
									[
										122534,
										122536
									],
									[
										122842,
										122844
									],
									[
										123099,
										123101
									],
									[
										123334,
										123336
									],
									[
										123588,
										123590
									],
									[
										123739,
										123741
									],
									[
										123988,
										123990
									],
									[
										124183,
										124185
									],
									[
										124443,
										124445
									],
									[
										124740,
										124742
									],
									[
										124925,
										124927
									],
									[
										125191,
										125193
									],
									[
										125249,
										125251
									],
									[
										125526,
										125528
									],
									[
										125580,
										125582
									],
									[
										125849,
										125851
									],
									[
										125924,
										125926
									],
									[
										126149,
										126151
									],
									[
										126208,
										126210
									],
									[
										126461,
										126463
									],
									[
										126698,
										126700
									],
									[
										126998,
										127000
									],
									[
										127283,
										127285
									],
									[
										127508,
										127510
									],
									[
										127782,
										127791
									],
									[
										127822,
										127831
									],
									[
										127846,
										127855
									],
									[
										127982,
										127991
									],
									[
										128134,
										128143
									],
									[
										128332,
										128341
									]
								],
								"scope": ""
							}
						},
						"selection":
						[
							[
								127988,
								127988
							]
						],
						"settings":
						{
							"detect_indentation": false,
							"line_numbers": false,
							"output_tag": 2,
							"result_base_dir": "",
							"result_file_regex": "^([A-Za-z\\\\/<].*):$",
							"result_line_regex": "^ +([0-9]+):",
							"scroll_past_end": true,
							"syntax": "Packages/Default/Find Results.hidden-tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 52935.0,
						"zoom_level": 1.0
					},
					"stack_index": 11,
					"type": "text"
				},
				{
					"buffer": 1,
					"file": "dnn_project/dnn/inputs/input.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1695,
						"regions":
						{
						},
						"selection":
						[
							[
								1026,
								1026
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 592.0,
						"zoom_level": 1.0
					},
					"stack_index": 9,
					"type": "text"
				},
				{
					"buffer": 2,
					"file": "dnn_project/dnn/base/register.x",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1321,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/Text/Plain text.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 10,
					"type": "text"
				},
				{
					"buffer": 3,
					"file": "dnn_project/dnn/base/constants.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3438,
						"regions":
						{
						},
						"selection":
						[
							[
								0,
								0
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 347.0,
						"zoom_level": 1.0
					},
					"stack_index": 8,
					"type": "text"
				},
				{
					"buffer": 4,
					"file": "dnn_project/dnn/reinforcements/input_classifier.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 874,
						"regions":
						{
						},
						"selection":
						[
							[
								480,
								480
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 12,
					"type": "text"
				},
				{
					"buffer": 5,
					"file": "dnn_project/dnn/inputs/input_time_series.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1946,
						"regions":
						{
						},
						"selection":
						[
							[
								1307,
								1307
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 575.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				},
				{
					"buffer": 6,
					"file": "dnn_project/dnn/util/time_series.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 9023,
						"regions":
						{
						},
						"selection":
						[
							[
								1077,
								1077
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 1,
					"type": "text"
				},
				{
					"buffer": 7,
					"file": "dnn_project/dnn/sim/sim.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 4478,
						"regions":
						{
						},
						"selection":
						[
							[
								759,
								759
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 0.0,
						"zoom_level": 1.0
					},
					"stack_index": 3,
					"type": "text"
				},
				{
					"buffer": 8,
					"file": "dnn_project/dnn/sim/builder.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 5217,
						"regions":
						{
						},
						"selection":
						[
							[
								4468,
								4468
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 1290.0,
						"zoom_level": 1.0
					},
					"stack_index": 2,
					"type": "text"
				},
				{
					"buffer": 9,
					"file": "dnn_project/dnn/sim/network.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2056,
						"regions":
						{
						},
						"selection":
						[
							[
								1887,
								1887
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 557.0,
						"zoom_level": 1.0
					},
					"stack_index": 4,
					"type": "text"
				},
				{
					"buffer": 10,
					"file": "dnn_project/dnn/util/spikes_list.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 1894,
						"regions":
						{
						},
						"selection":
						[
							[
								1274,
								1274
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 1000.0,
						"zoom_level": 1.0
					},
					"stack_index": 5,
					"type": "text"
				},
				{
					"buffer": 11,
					"file": "dnn_project/tools/dnn_sim/dnn_sim.cpp",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 3112,
						"regions":
						{
						},
						"selection":
						[
							[
								2754,
								2754
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage"
						},
						"translation.x": 0.0,
						"translation.y": 1418.0,
						"zoom_level": 1.0
					},
					"stack_index": 7,
					"type": "text"
				},
				{
					"buffer": 12,
					"file": "dnn_project/dnn/neurons/spike_sequence_neuron.h",
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 2641,
						"regions":
						{
						},
						"selection":
						[
							[
								2122,
								2122
							]
						],
						"settings":
						{
							"syntax": "Packages/C++/C++.tmLanguage",
							"tab_size": 4,
							"translate_tabs_to_spaces": true
						},
						"translation.x": 0.0,
						"translation.y": 881.0,
						"zoom_level": 1.0
					},
					"stack_index": 6,
					"type": "text"
				}
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
			]
		}
	],
	"incremental_find":
	{
<<<<<<< HEAD
		"height": 34.0
=======
		"height": 25.0
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
	},
	"input":
	{
		"height": 34.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			]
		],
		"cols":
		[
			0.0,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 118.0
	},
	"output.find_results":
	{
		"height": 0.0
	},
	"output.sbt":
	{
		"height": 0.0
	},
	"output.sbt_error":
	{
		"height": 0.0
	},
	"pinned_build_system": "",
	"project": "dnn.sublime-project",
	"replace":
	{
		"height": 64.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
			[
<<<<<<< HEAD
				"stati",
				"dnn_project/dnn/synapses/static_synapse.h"
			],
			[
				"sim.c",
				"dnn_project/dnn/sim/sim.cpp"
			],
			[
				"rew",
				"dnn_project/dnn/sim/reward_control.h"
			],
			[
				"stat",
				"dnn_project/shapelets/stats.h"
			],
			[
				"inpu",
				"dnn_project/dnn/reinforcements/input_classifier.h"
			],
			[
				"rein",
				"dnn_project/dnn/reinforcements/reinforcement.h"
			],
			[
				"spi",
				"dnn_project/dnn/neurons/spike_neuron.h"
			],
			[
				"register",
				"dnn_project/dnn/base/register.x"
			],
			[
				"we",
				"dnn_project/dnn/weight_normalizations/weight_normalization.h"
=======
				"build",
				"dnn_project/dnn/sim/builder.cpp"
			],
			[
				"sim",
				"dnn_project/dnn/sim/sim.cpp"
			],
			[
				"sim.",
				"dnn_project/dnn/sim/sim.cpp"
			],
			[
				"net",
				"dnn_project/dnn/sim/network.h"
			],
			[
				"spi",
				"dnn_project/dnn/util/spikes_list.h"
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
			],
			[
				"regis",
				"dnn_project/dnn/base/register.x"
			],
			[
<<<<<<< HEAD
				"spik",
				"dnn_project/dnn/neurons/spike_neuron.h"
			],
			[
				"sp",
				"dnn_project/dnn/neurons/spike_neuron.h"
			],
			[
				"cons",
				"dnn_project/dnn/base/constants.cpp"
			],
			[
				"json",
				"dnn_project/dnn/util/json.cpp"
			],
			[
				"str",
				"dnn_project/dnn/io/stream.h"
			],
			[
				"bui",
				"dnn_project/dnn/sim/builder.cpp"
			],
			[
				"fa",
				"dnn_project/dnn/base/factory.cpp"
			],
			[
				"dnn",
				"dnn_project/tools/dnn_sim/dnn_sim.cpp"
			],
			[
				"opt",
				"dnn_project/dnn/learning_rules/optimal_stdp.h"
			],
			[
				"stai",
				"dnn_project/dnn/util/statistics.h"
=======
				"dnn",
				"dnn_project/tools/dnn_sim/dnn_sim.cpp"
			],
			[
				"ptr",
				"dnn_project/dnn/util/ptr.h"
			],
			[
				"glo",
				"dnn_project/dnn/sim/global_ctx.h"
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
			],
			[
				"sim.c",
				"dnn_project/dnn/sim/sim.cpp"
			],
			[
<<<<<<< HEAD
				"rewa",
				"dnn_project/dnn/sim/reward_control.h"
			],
			[
				"glo",
				"dnn_project/dnn/sim/global_ctx.h"
			],
			[
				"ba",
				"dnn_project/dnn/base/base.h"
			],
			[
				"le",
				"dnn_project/dnn/learning_rules/learning_rule.h"
			],
			[
				"uti",
				"dnn_project/dnn/util/util.cpp"
			],
			[
				"net",
				"dnn_project/dnn/sim/network.h"
			],
			[
				"buil",
				"dnn_project/dnn/sim/builder.h"
			],
			[
				"spike_ne",
				"dnn_project/dnn/neurons/spike_neuron.h"
			],
			[
				"time",
				"dnn_project/dnn/util/time_series.h"
			],
			[
				"ser",
				"dnn_project/dnn/io/serialize.h"
			],
			[
				"spike_seq",
				"dnn_project/dnn/neurons/spike_sequence_neuron.h"
			],
			[
				"sike",
				"dnn_project/dnn/util/spikes_list.h"
			],
			[
				"stre",
				"dnn_project/dnn/io/stream.h"
			],
			[
				"ne",
				"dnn_project/dnn/sim/network.h"
			],
			[
				"spike",
				"dnn_project/dnn/util/spikes_list.h"
			],
			[
				"spike_s",
				"dnn_project/dnn/neurons/spike_sequence_neuron.h"
=======
				"input",
				"dnn_project/dnn/inputs/input_time_series.h"
			],
			[
				"regi",
				"dnn_project/dnn/base/register.x"
			],
			[
				"spike_seq",
				"dnn_project/dnn/neurons/spike_sequence_neuron.h"
			],
			[
				"inpu",
				"dnn_project/dnn/inputs/input_time_series.h"
			],
			[
				"conv",
				"dnn_project/spikework/conv.cpp"
			],
			[
				"ker",
				"dnn_project/spikework/kernel.cpp"
			],
			[
				"ser",
				"dnn_project/dnn/io/serialize.h"
			],
			[
				"inp",
				"dnn_project/dnn/inputs/input_time_series.h"
			],
			[
				"rm",
				"src/RMpl.h"
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
			],
			[
				"ut",
				"dnn_project/dnn/util/util.cpp"
			],
			[
				"fa",
				"dnn_project/dnn/base/factory.h"
			],
			[
				"pt",
				"dnn_project/dnn/util/ptr.h"
			],
			[
				"spieq",
				"dnn_project/dnn/neurons/spike_sequence_neuron.h"
			],
			[
				"rpr",
				"src/RProto.h"
			],
			[
				"t",
				"dnn_project/dnn/util/time_series.cpp"
			],
			[
<<<<<<< HEAD
				"kern",
				"dnn_project/spikework/kernel.cpp"
			],
			[
				"sim.",
				"dnn_project/dnn/sim/sim.cpp"
			],
			[
				"sub",
				"dnn_project/shapelets/subsequence.h"
			],
			[
				"ptr",
				"dnn_project/dnn/util/ptr.h"
=======
				"tim",
				"dnn_project/dnn/util/time_series.cpp"
			],
			[
				"ke",
				"dnn_project/spikework/kernel.cpp"
			],
			[
				"str",
				"dnn_project/dnn/io/stream.cpp"
			],
			[
				"rk",
				"src/RKernel.cpp"
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
			],
			[
				"io",
				"dnn_project/spikework/io_worker.h"
			],
			[
				"uti",
				"src/util.cpp"
			],
			[
				"lo",
				"dnn_project/dnn/util/log/log.h"
			],
			[
				"kern",
				"dnn_project/spikework/kernel.h"
			],
			[
<<<<<<< HEAD
				"base",
				"dnn_project/dnn/base/base.h"
=======
				"sp",
				"dnn_project/spikework/spikework.cpp"
			],
			[
				"ano",
				"dnn_project/spikework/kernels/anova_dot.cpp"
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
			],
			[
				"rbf",
				"dnn_project/spikework/kernels/rbf_dot.cpp"
			],
			[
				"shoe",
				"dnn_project/spikework/kernels/shoe.cpp"
			],
			[
				"make",
				"src/Makevars.in"
			],
			[
				"an",
				"dnn_project/spikework/kernels/anova_dot.cpp"
			],
			[
				"le",
				"dnn_project/dnn/learning_rules/learning_rule.h"
			],
			[
				"rmp",
				"src/RMpl.h"
			],
			[
				"rke",
				"src/RKernel.cpp"
			],
			[
				"rp",
				"src/RProto.h"
			],
			[
				"ma",
				"dnn_project/dnn/util/matrix.h"
			],
			[
<<<<<<< HEAD
				"spike_n",
				"dnn_project/dnn/neurons/spike_neuron.h"
=======
				"mod",
				"src/mod.cpp"
			],
			[
				"spike",
				"dnn_project/dnn/util/spikes_list.h"
			],
			[
				"buil",
				"dnn_project/dnn/sim/builder.cpp"
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
			],
			[
				"ne",
				"dnn_project/dnn/sim/network.h"
			],
			[
				"",
				"src/RSim.cpp"
			],
			[
				"rs",
				"src/RSim.cpp"
			],
			[
<<<<<<< HEAD
				"inte",
				"dnn_project/dnn/util/interfaced_ptr.h"
=======
				"rsi",
				"src/RSim.cpp"
			],
			[
				"fac",
				"dnn_project/dnn/base/factory.cpp"
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
			],
			[
				"rsim",
				"src/RSim.cpp"
			],
			[
				"leak",
				"dnn_project/dnn/neurons/leaky_integrate_and_fire.h"
			],
			[
				"ga",
				"dnn_project/dnn/util/gammatone_fb.h"
			],
			[
				"cons",
				"dnn_project/dnn/base/constants.h"
			],
			[
				"ba",
				"dnn_project/dnn/base/base.h"
			],
			[
				"mo",
				"src/mod.cpp"
			],
			[
				"r",
				"src/RConstants.h"
			],
			[
<<<<<<< HEAD
				"inter",
				"dnn_project/dnn/util/interfaced_ptr.h"
=======
				"dte",
				"dnn_project/dnn/act_functions/determ.h"
			],
			[
				"rco",
				"src/RConstants.h"
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
			],
			[
				"spike_",
				"dnn_project/dnn/neurons/spike_neuron.cpp"
			],
			[
				"bui",
				"dnn_project/dnn/sim/builder.cpp"
			],
			[
				"spike_ne",
				"dnn_project/dnn/neurons/spike_neuron.h"
			],
			[
				"ex",
				"dnn_project/dnn/act_functions/exp_threshold.h"
			],
			[
				"base",
				"dnn_project/dnn/base/base.h"
			],
			[
				"seri",
				"dnn_project/dnn/io/serialize.h"
			],
			[
				"sha",
				"dnn_project/shapelets/shapelets_algo.cpp"
			],
			[
				"std",
				"dnn_project/dnn/learning_rules/stdp.h"
			],
			[
				"ord",
				"dnn_project/shapelets/orderline.cpp"
			],
			[
				"spa",
				"dnn_project/shapelets/shapelets_algo.cpp"
			],
			[
				"or",
				"dnn_project/shapelets/orderline.cpp"
			],
			[
				"sh",
				"dnn_project/shapelets/shapelets_algo.cpp"
			],
			[
				"fft",
				"dnn_project/spikework/fft.cpp"
			],
			[
				"fun",
				"dnn_project/dnn/util/func_param_parser.cpp"
			],
			[
				"sho",
				"dnn_project/spikework/kernels/shoe.cpp"
			],
			[
				"faste",
				"dnn_project/dnn/util/fastapprox/fastexp.h"
			],
			[
				"fas",
				"dnn_project/dnn/util/fastapprox/fastpow.h"
			],
			[
				"ep",
				"dnn_project/spikework/kernels/epsp.cpp"
			],
			[
				"dot",
				"dnn_project/spikework/kernels/dot.cpp"
			],
			[
				"do",
				"dnn_project/spikework/kernels/dot.h"
			],
			[
				"optio",
				"dnn_project/dnn/util/option_parser.cpp"
			],
			[
				"opt",
				"dnn_project/dnn/util/option_parser.h"
			],
			[
				"con",
				"dnn_project/spikework/conv.cpp"
			],
			[
				"gr",
				"dnn_project/spikework/gram.cpp"
			],
			[
				"gram",
				"dnn_project/spikework/gram.cpp"
			],
			[
<<<<<<< HEAD
				"lo",
				"dnn_project/dnn/util/log/log.h"
=======
				"core",
				"dnn_project/dnn/core.h"
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
			],
			[
				"log",
				"dnn_project/dnn/util/log/log.h"
			],
			[
				"ac",
				"dnn_project/dnn/util/act_vector.h"
			],
			[
				"act",
				"dnn_project/dnn/util/act_vector.h"
			],
			[
				"ff",
				"dnn_project/spikework/fft.h"
			],
			[
				"re",
				"dnn_project/spikework/read.h"
			],
			[
				"stre",
				"dnn_project/dnn/io/stream.cpp"
			],
			[
				"rpro",
				"src/RProto.h"
			],
			[
				"rmpl",
				"src/RMpl.h"
			],
			[
				"mpl",
				"dnn_project/tools/mpl/mpl_main.cpp"
			],
			[
				"spikes_l",
				"dnn_project/dnn/util/spikes_list.h"
			],
			[
				"shape",
				"dnn_project/tools/shapelets/shapelets.cpp"
			],
			[
				"mpl_ma",
				"dnn_project/tools/mpl/mpl_main.cpp"
			],
			[
				"log.",
				"dnn_project/dnn/util/log/log.h"
			],
			[
				"comm",
				"src/common.h"
			],
			[
				"format.h",
				"dnn_project/dnn/contrib/spdlog/details/format.h"
			],
			[
				"format",
				"dnn_project/dnn/contrib/spdlog/details/format.h"
			],
			[
				"shap",
				"dnn_project/shapelets/shapelets_algo.h"
			],
			[
				"shae",
				"dnn_project/shapelets/shapelets_algo.cpp"
			],
			[
				"sio",
				"dnn_project/spikework/io_processor.cpp"
			],
			[
				"gra",
				"dnn_project/spikework/gram.cpp"
			],
			[
				"matr",
				"dnn_project/dnn/protos/matrix.proto"
			],
			[
				"mat",
				"dnn_project/dnn/protos/matrix.proto"
			],
			[
				"kiss",
				"dnn_project/dnn/contrib/kiss_fft/kiss_fftnd.h"
			],
			[
				"da",
				"dnn_project/shapelets/dataset.h"
			],
			[
				"pro",
				"dnn_project/shapelets/projection.h"
			],
			[
				"pr",
				"dnn_project/shapelets/projection.h"
			],
			[
				"di",
				"dnn_project/shapelets/dist.cpp"
			],
			[
				"data",
				"dnn_project/shapelets/dataset.h"
			],
			[
<<<<<<< HEAD
				"or",
				"dnn_project/shapelets/orderline.h"
=======
				"sub",
				"dnn_project/shapelets/subsequence.cpp"
			],
			[
				"proj",
				"dnn_project/shapelets/projection.h"
			],
			[
				"dis",
				"dnn_project/shapelets/dist.cpp"
			],
			[
				"stat",
				"dnn_project/shapelets/stats.cpp"
			],
			[
				"subs",
				"dnn_project/shapelets/subsequence.cpp"
			],
			[
				"dist",
				"sources/shapelets/dist.cpp"
			],
			[
				"stats",
				"sources/shapelets/stats.cpp"
			],
			[
				"subse",
				"sources/shapelets/subsequence.h"
			],
			[
				"dat",
				"sources/shapelets/dataset.h"
			],
			[
				"op",
				"sources/dnn/util/option_parser.h"
			],
			[
				"js",
				"sources/dnn/util/json.h"
			],
			[
				"exc",
				"sources/dnn/base/exceptions.h"
>>>>>>> a99ed8a47ef80e838932012aaf3295127b9167fb
			]
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 500.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 380.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 201.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
